I"<h4 id="sql-중심-개발의-문제점">SQL 중심 개발의 문제점</h4>
<p>중요한 데이터를 보관하기 위해서 많은 회사들이 관계형 데이터베이스를 사용하고 있다. 그래서 관계형 데이터베이스가 이해할 수 있는 SQL이 중요하다.</p>

<h3 id="sql-mapper">SQL Mapper</h3>
<p>SQL Mapper는 개발자가 작성한 SQL문으로 해당되는 데이터를 읽고, 결과값을 객체화시켜 사용할 수 있게 해준다. 즉, RDB에 따라 SQL 문법이 다르므로 특정 RDB에 종속적이다.</p>
<ul>
  <li>예) MyBatis</li>
</ul>

<h3 id="ormobject-relational-mapping">ORM(Object-Relational Mapping)</h3>
<p>ORM은 객체는 객체대로 설계하고, 관계형 데이터베이스(RDB)는 관계형 데이터베이스대로 설계 후 ORM 프레임워크가 중간에서 매핑해주는 것을 의미한다. 요즘 대중적인 언어에는 대부분 ORM 기술이 존재한다.
ORM은 객체와 RDB를 별개로 설계하고, ORM이 중간에서 매핑해주는 역할을 한다. 즉, ORM은 SQL문이 아닌 RDB에 데이터 자체를 매핑하기 때문에 SQL을 직접 작성할 필요가 없다.
해당 객체와의 매핑을 위한 SQL을 알아서 제공한다. 이로인해 어떤 RDB를 사용하던 상관이 없어졌다.
SQL문이 아닌 ORM에서 제공하는 메서드, 코드 또한 직관적이어서 사용하기 좋다.</p>
<ul>
  <li>예) Hibernate, JPA 등</li>
</ul>

<p><br /></p>

<hr />
<h3 id="mybatisjava-persistence-framework">MyBatis(Java Persistence Framework)</h3>
<p>MyBatis는 SQL Mapper의 일종으로 개발자가 지정한 SQL, 저장 프로시저 그리고 몇 가지 고급 매핑을 지원하는 영속성 프레임워크다.
MyBatis는 JDBC로 처리하는 상당 부분의 코드와 파라미터 설정 및 결과 매핑을 대신해주고, 데이터베이스 record에 원시 타입과 Map 그리고 Java POJO를 설정하여 매핑하기 위해 XML과 Annotation을 사용할 수 있다. 즉, SQL문을 직접 작성하여 객체와 매핑시켜준다.</p>

<h4 id="장점">장점</h4>
<ul>
  <li>SQL 쿼리를 직접 작성하므로 최적화된 쿼리를 구현할 수 있다.</li>
  <li>SQL의 세부적인 내용 변경 시 좀 더 간편하다.</li>
  <li>동적 쿼리 사용 시 JPA보다 간편하게 구현 가능하다.</li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>쿼리를 직접 작성하기 때문에 데이터베이스 변경 시 수정할 부분이 굉장히 많다. (특정 DB에 종속적이다)</li>
  <li>Mapper 작성부터 인터페이스 설계까지 JPA 보다 많은 설계와 파일, 로직이 필요하다.</li>
  <li>런타임 시 에러를 발견할 수 있다.</li>
  <li>비슷한 코드를 반복적으로 작업하게 된다.</li>
</ul>

<p><br /></p>

<hr />
<h3 id="jpajava-persistence-api">JPA(Java Persistence API)</h3>
<p>JPA는 Java ORM의 기술 표준에 대한 API 표준 명세로, 단순한 명세이기 때문에 Hibernate, DataNucleus, EpliseLink 등 다양한 구현체를 사용해야 한다.
실무에서 자주 사용하는 Spring Data JPA는 JPA를 간편하게 사용하기 위한 오픈 소스로 Spring Data Redis, Spring Data MongoDB 등 다양한 라이브러리가 존재한다.</p>

<h4 id="장점-1">장점</h4>
<ul>
  <li>RDB 종류에 상관없이 사용 가능하여 추후 DB 변경이나 코드 재사용에 용이하다.</li>
  <li>기본적인 CRUD 제공과 페이징 처리 등 상당 부분이 구현되어 있어 비즈니스 로직에 집중할 수 있다.</li>
  <li>테이블 생성, 변경 등 엔티티 관리가 간편하다.</li>
  <li>객체지향적으로 데이터를 관리할 수 있다.</li>
  <li>컴파일 시에 에러를 발견할 수 있다.</li>
</ul>

<h4 id="단점-1">단점</h4>
<ul>
  <li>제대로 이해하지 않고 코딩하면 성능상의 문제가 반드시 발생한다. (연관관계, FetchType, Proxy 등등)</li>
  <li>고도화 될수록 학습 곡선이 높아질 수 있다. (성능 이슈의 연장선으로 해결 방안에 따라 복잡한 내부 로직을 이해해야 할 필요가 있다)</li>
  <li>JPA만 사용하여 복잡한 연산을 수행하기엔 다소 무리가 있다. (로직이 복잡하거나 불필요한 쿼리가 발생할 수 있다)</li>
</ul>

<p><br /></p>

<hr />
<h3 id="개인적인-의견">개인적인 의견</h3>
<p>단점으로 러닝 커브와 복잡한 연산에 무리가 있다고 했지만 요즘엔 QueryDsl 같은 조회용 프레임워크를 함께 사용하여 그 간극을 줄이고 있다. 개인적으로 자바 개발자라면 한 번쯤 꼭 배워보는게 좋다고 생각한다.</p>

<p><br /></p>

<hr />
<p><br /> 
<strong>참고</strong></p>
<ul>
  <li></li>
  <li><a href="https://dreaming-soohyun.tistory.com/entry/JPA%EC%99%80-MyBatis%EC%9D%98-%EC%B0%A8%EC%9D%B4-ORM%EA%B3%BC-SQL-Mapper">https://dreaming-soohyun.tistory.com/entry/JPA%EC%99%80-MyBatis%EC%9D%98-%EC%B0%A8%EC%9D%B4-ORM%EA%B3%BC-SQL-Mapper</a></li>
  <li><a href="https://incheol-jung.gitbook.io/docs/q-and-a/spring/jpa-vs-mybatis">https://incheol-jung.gitbook.io/docs/q-and-a/spring/jpa-vs-mybatis</a></li>
</ul>
:ET