I"<h3 id="jwtjson-web-token-">JWT(JSON Web Token) ?</h3>
<ul>
  <li><em>JWT(Json Web Token)</em>란 인증에 필요한 JSON 데이터를 암호화시켜 저장한 Web Token
<br /></li>
</ul>

<h4 id="왜-jwt를-사용할까">왜 JWT를 사용할까?</h4>
<ul>
  <li>HTTP는 <strong>무상태(Stateless)</strong>와 <strong>비연결성(Connectionless)</strong>이라는 특성을 가지고 있다.
    <ol>
      <li><strong>Stateless</strong>: 이전 상태를 유지/기억하지 않음
        <ul>
          <li>장점: 서버의 확장성이 높음</li>
          <li>단점: 클라이언트에게 추가 데이터를 전송해야 함</li>
        </ul>
      </li>
      <li><strong>Connectionless</strong>: 연결을 유지하지 않음</li>
    </ol>
  </li>
  <li>연결을 유지하지 않고(Connectionless) 이전 상태도 기억하지 못한다(Stateless)는 것은 이동하는 페이지마다 요청을 새로 해야한다는 것을 의미한다. 즉, 사용자가 신뢰성이 있는 사용자인지 매번 인증해야 한다.</li>
  <li>이는 번거로울 뿐만 아니라 통신이 느려질 수도 있기 때문에 한 번 인증된 사용자가 일정 기간 인증을 유지하도록 JWT를 사용한다.
<br />
<br /></li>
</ul>

<h3 id="jwt의-구조">JWT의 구조</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xxxxxx</span><span class="o">.</span><span class="na">yyyyyy</span><span class="o">.</span><span class="na">zzzzzz</span> <span class="c1">// Header.Payload.Signature</span>
</code></pre></div></div>
<ul>
  <li>JWT는 <code class="language-plaintext highlighter-rouge">.</code>을 구분자로 나누어 구성된 3가지 문자열이다.</li>
  <li>Header, Payload는 Base64 URL-safe로 인코딩되어 누구나 쉽게 복호화할 수 있기 때문에 절대 중요한 정보를 넣으면 안 되지만, Signature는 비밀키가 없으면 복호화할 수 없기 때문에 보안상 안전하다.</li>
</ul>

<h4 id="header">Header</h4>
<ul>
  <li>Signature를 해싱하기 위한 해시 알고리즘 정보, 토큰 타입</li>
</ul>

<h4 id="payload">Payload</h4>
<ul>
  <li>서버와 클라이언트가 주고 받으며, 시스템에서 실제로 사용될 정보에 대한 내용들
    <ul>
      <li>대상, 이름, 발급일시, 만료일시 등</li>
    </ul>
  </li>
</ul>

<h4 id="signature">Signature</h4>
<ul>
  <li>Header + Payload + 비밀키(서명)를 Header의 알고리즘으로 암호화한 문자열
    <ul>
      <li>토큰의 위변조 여부를 확인하기 위해 사용됨</li>
      <li>Signature가 공개되지 않는 이상 Header나 Payload의 데이터를 위조해도, Signature를 통해 유효한 토큰인지 알 수 있음
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h3 id="장점">장점</h3>
<ul>
  <li>Base64 URL Safe로 인코딩하기 때문에 URL, Cookie, Header 모두 사용 가능하다. (범용성)</li>
  <li>로컬에 저장하기 때문에 서버 용량에 영향을 주거나 받지 않는다.</li>
  <li>개인키를 통해 서명하기 때문에 보다 안전하다.</li>
  <li>HTTP 헤더나 URL 파라미터로 간단하게 전송하기 때문에 네트워크 부하가 적다.
<br /></li>
</ul>

<h3 id="단점">단점</h3>
<ul>
  <li>Payload에 저장되는 정보가 많아지면 네트워크 사용량이 증가하여, 데이터 설계 고려가 필요해진다.</li>
  <li>토큰이 클라이언트에 저장되어, 서버에서 클라이언트의 토큰을 조작할 수 없다.</li>
  <li>토큰이 발급되면 중간에 만료 기간 변경이 불가능하므로, 토큰 만료 처리를 구현해야 한다.
<br />
<br /></li>
</ul>

<h3 id="정리">정리</h3>
<p>JWT도 토큰 탈취의 보안 위험에서 벗어날 수 없기 때문에, 실무에서는 AccessToken과 RefreshToken처럼 기한이 있는 인증 방식을 사용한다.</p>

<p>둘 다 JWT로 구현되지만, AccessToken은 기한이 짧고(몇 시간에서 며칠) 클라이언트에 저장된다.
RefreshToken은 AccessToken보다 수명이 길어(2주 이상) AccessToken의 재발급을 위해 사용하며 최근에는 보안을 위해 데이터베이스에 저장하고 있다.</p>

<p>그리고 AccessToken는 만료 기한이 짧기 때문에 로그인을 자주 해야하는 번거로움이 있을 수 있으니 AccessToken만 사용하기보다는 RefreshToken을 함께 사용해서 편리하고 보안을 강화하는 게 좋아보인다.
<br />
<br /></p>

<h4 id="참고">참고</h4>
<ul>
  <li>https://jwt.io</li>
  <li><a href="https://velog.io/@chuu1019/%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-JWTJson-Web-Token">https://velog.io/@chuu1019/알고-쓰자-JWTJson-Web-Token</a></li>
  <li>https://inpa.tistory.com/559</li>
  <li>https://puleugo.tistory.com/138</li>
</ul>
:ET