<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Queue | Every Single Day</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="Queue">
<meta name="author" content="Dajeong Park">
<meta property="og:locale" content="ko">
<meta name="description" content="Queue(선형 큐) 특징 줄 서있는 것처럼 선입선출(FIFO) 형태의 자료구조 정해진 한 곳(top)을 통해서 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에서 삽입 작업, 다른 쪽에서 삭제 작업이 양쪽으로 이루어진다. 큐의 뒤(rear)에서만 삽입(enqueue)하고, 큐의 앞(front)에서는 삭제(dequeue)만 이루어진다. 자바에서는 스택을 Stack 클래스로 구현하여 제공하지만, 큐는 Queue 인터페이스만 있고 별도의 클래스가 없다. 그래서 Queue 인터페이스를 구현한 클래스를 사용해야 한다.">
<meta property="og:description" content="Queue(선형 큐) 특징 줄 서있는 것처럼 선입선출(FIFO) 형태의 자료구조 정해진 한 곳(top)을 통해서 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에서 삽입 작업, 다른 쪽에서 삭제 작업이 양쪽으로 이루어진다. 큐의 뒤(rear)에서만 삽입(enqueue)하고, 큐의 앞(front)에서는 삭제(dequeue)만 이루어진다. 자바에서는 스택을 Stack 클래스로 구현하여 제공하지만, 큐는 Queue 인터페이스만 있고 별도의 클래스가 없다. 그래서 Queue 인터페이스를 구현한 클래스를 사용해야 한다.">
<link rel="canonical" href="http://localhost:4000/wiki/2024/03/05/queue.html">
<meta property="og:url" content="http://localhost:4000/wiki/2024/03/05/queue.html">
<meta property="og:site_name" content="Every Single Day">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-03-05T00:00:00+09:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Queue">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Dajeong Park"},"dateModified":"2024-03-05T00:00:00+09:00","datePublished":"2024-03-05T00:00:00+09:00","description":"Queue(선형 큐) 특징 줄 서있는 것처럼 선입선출(FIFO) 형태의 자료구조 정해진 한 곳(top)을 통해서 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에서 삽입 작업, 다른 쪽에서 삭제 작업이 양쪽으로 이루어진다. 큐의 뒤(rear)에서만 삽입(enqueue)하고, 큐의 앞(front)에서는 삭제(dequeue)만 이루어진다. 자바에서는 스택을 Stack 클래스로 구현하여 제공하지만, 큐는 Queue 인터페이스만 있고 별도의 클래스가 없다. 그래서 Queue 인터페이스를 구현한 클래스를 사용해야 한다.","headline":"Queue","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/wiki/2024/03/05/queue.html"},"url":"http://localhost:4000/wiki/2024/03/05/queue.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="apple-touch-icon" sizes="57x57" href="/assets/favicon.ico/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/favicon.ico/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/favicon.ico/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/favicon.ico/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/favicon.ico/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/favicon.ico/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/favicon.ico/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/favicon.ico/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon.ico/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/assets/favicon.ico/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.ico/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/favicon.ico/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon.ico/favicon-16x16.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Every Single Day">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Every Single Day" src="" onerror="this.style.display='none'">
  Every Single Day
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/categories.html">CATEGORIES</a><a class="page-link" href="/tags.html">TAGS</a>




</div>
        </nav>
</div>
  </div>
</header>

<script>
  (function() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;

      var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  })();
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<!--<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
-->

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">Queue</h1>
  <h2 class="post-subtitle"></h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2024-03-05T00:00:00+09:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Mar 05, 2024
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 10 mins</span>
  </p>
<div class="post-tags">
<a class="post-tag" href="/tags.html#DataStructure">#DataStructure</a><a class="post-tag" href="/tags.html#Queue">#Queue</a>
</div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h3 id="queue선형-큐">Queue(선형 큐)</h3>
<h4 id="특징">특징</h4>
<ul>
  <li>줄 서있는 것처럼 선입선출(FIFO) 형태의 자료구조</li>
  <li>정해진 한 곳(top)을 통해서 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에서 삽입 작업, 다른 쪽에서 삭제 작업이 양쪽으로 이루어진다.</li>
  <li>큐의 뒤(rear)에서만 삽입(enqueue)하고, 큐의 앞(front)에서는 삭제(dequeue)만 이루어진다.</li>
  <li>자바에서는 스택을 Stack 클래스로 구현하여 제공하지만, 큐는 Queue 인터페이스만 있고 별도의 클래스가 없다. 그래서 Queue 인터페이스를 구현한 클래스를 사용해야 한다.
<br>
</li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>선형 큐에서 삽입/삭제를 반복하다 보면, rear가 맨 마지막 인덱스를 가리키고 앞에는 비어있을 수 있지만 이를 꽉 찼다고 인식한다. 데이터를 삭제할 때마다 한 칸 앞으로 이동시키는 것이 아니라 인덱스 단위로 큐의 연산을 진행하기 때문에 이러한 문제점이 있다. 이러한 단점을 보완하기 위해 Circular Queue(원형 큐)가 생겨났다.
<br>
</li>
</ul>

<h4 id="메소드">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="n">자료형</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>
<p><strong><code class="language-plaintext highlighter-rouge">boolean add(E value)</code></strong></p>
<ul>
  <li>value 삽입 성공 시 true, 실패 시 Exception 발생</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean offer(E value)</code></strong></p>
<ul>
  <li>value 삽입 성공 시 true, 실패 시 false 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E remove(E value)</code></strong></p>
<ul>
  <li>value 삭제 성공 시 삭제된 value, 공백 큐라면 Exception(NoSuchElementException) 발생</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean remove(E value)</code></strong></p>
<ul>
  <li>해당 value가 존재하면 삭제 후 true, 존재하지 않으면 false 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E poll(E value)</code></strong></p>
<ul>
  <li>value 삭제 성공 시 삭제된 value, 공백 큐라면 null 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E element()</code></strong></p>
<ul>
  <li>head에 위치한 value를 리턴하거나, 공백 큐라면 Exception(NoSuchElementException) 발생</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E peek()</code></strong></p>
<ul>
  <li>head에 위치한 value를 리턴하거나, 공백 큐라면 null 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">void clear()</code></strong></p>
<ul>
  <li>해당 큐를 초기화 함(공백 큐로 만듦)</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">int size()</code></strong></p>
<ul>
  <li>큐의 사이즈를 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean contains(E value)</code></strong></p>
<ul>
  <li>value가 존재하면 true, 없으면 false 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean isEmpty()</code></strong></p>
<ul>
  <li>공백 큐라면 true, 아니라면 false 리턴
<br>
</li>
</ul>

<h4 id="활용">활용</h4>
<ul>
  <li>큐는 주로 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용한다.</li>
  <li>우선순위가 같은 작업 예약 (프린터의 인쇄 대기열)
    <ul>
      <li>작업 스케줄링</li>
    </ul>
  </li>
  <li>은행 업무</li>
  <li>콜센터 고객 대기 시간</li>
  <li>프로세스 관리</li>
  <li>너비 우선 탐색(BFS, Breadth-First Search) 구현</li>
  <li>캐시(Cache) 구현</li>
  <li>버퍼: 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역 (입출력 및 네트워크에서 사용)
<br>
<br>
</li>
</ul>

<h3 id="circular-queue">Circular Queue</h3>
<h4 id="특징-1">특징</h4>
<ul>
  <li>1차원 배열을 사용하여 구현한다.</li>
  <li>초기 front와 rear는 맨 처음 인덱스에 위치한다.</li>
  <li>front와 rear를 회전시키기 위해서 모듈러(%) 연산을 사용한다.</li>
  <li><br></li>
</ul>

<h4 id="주요-연산">주요 연산</h4>
<ul>
  <li>
<strong>enQueue</strong>: (rear + 1) % (배열의 크기)
    <ul>
      <li>만약 rear + 1이 front와 같으면 해당 큐는 꽉 찬 것이다.</li>
      <li>배열의 크기가 11인 배열의 index 10까지 모두 채우면, 다음 rear는 11이 아니라 0이 된다.</li>
    </ul>
  </li>
  <li>
<strong>deQueue</strong>: (front + 1) % (배열의 크기)</li>
  <li>
<strong>size</strong>: (배열의 크기 + rear - front) % (배열의 크기)
    <ul>
      <li>주의사항: rear == front(가득 찼을 때)도 마찬가지로 0이 된다.</li>
    </ul>
  </li>
  <li>
<strong>full</strong>: (rear + 1) % (배열의 크기) == front</li>
  <li>
<strong>empty</strong>: rear == front
<br>
<br>
</li>
</ul>

<h3 id="priority-queue">Priority Queue</h3>
<h4 id="특징-2">특징</h4>
<ul>
  <li>Queue 인터페이스를 구현하였다.</li>
  <li>저장한 순서에 상관없이 우선순위(priority)가 높은 것부터 꺼낸다.</li>
  <li>null을 저장하면 NPE가 발생한다.</li>
  <li>배열을 사용하며, 각 요소를 힙이라는 자료구조의 형태로 저장한다. (JVM의 힙과 자료구조의 힙은 다르다!)</li>
  <li>지정하지 않으면 숫자가 작을 수록 우선순위가 높다.</li>
  <li>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html">Priority Queue API</a>
<br>
</li>
</ul>

<h4 id="구현-방법">구현 방법</h4>
<ul>
  <li>배열을 기반으로 구현하는 방법</li>
  <li>연결 리스트를 기반으로 구현하는 방법</li>
  <li>힙(heap)을 이용하는 방법</li>
  <li>배열이나 연결 리스트로 구현할 경우 간단하게 구현이 가능하지만, 데이터 삽입과 삭제 과정에서 데이터를 한 칸씩 당기거나 밀어야 하는 연산을 계속해야 한다. 또 삽입의 위치를 찾기 위해 배열에 저장된 모든 데이터와 우선순위를 비교해야 한다.</li>
  <li>연결 리스트의 경우, 삽입의 위치를 찾기 위해 첫번째 노트부터 싲가하여 마지막 노드에 저장된 데이터와 우선순위를 비교해야 할 수도 있다. (성능 저하) 그래서 일반적으로 힙을 이용하여 구현한다.
<br>
<br>
</li>
</ul>

<h3 id="dequeue">Dequeue</h3>
<h4 id="특징-3">특징</h4>
<ul>
  <li>데이터의 추가와 삭제를 양쪽 끝에서 가능하게 하는 자료구조 (큐와 스택을 합친 형태로 생각할 수 있음)</li>
  <li>연속적인 메모리를 기반으로 하는 ‘시퀀스 컨테이너’이다. 따라서 임의 접근 반복자를 제공한다.</li>
  <li>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html">Deque API</a>
<br>
</li>
</ul>

<h4 id="유형">유형</h4>
<ul>
  <li>
<strong>scroll</strong>: 입력 제한 덱, 입력이 한쪽으로만 일어나도록 제한</li>
  <li>
<strong>self</strong>: 출력 제한 덱, 출력이 한쪽으로만 일어나도록 제한
<br>
</li>
</ul>

<h4 id="활용-1">활용</h4>
<ul>
  <li>스케줄링: 스케줄링이 복잡해질 수록 스택과 덱보다 효율이 잘 나오는 경우가 있다.</li>
  <li>우선순위 조절: 한 방향으로만 삽입/삭제가 가능한 스택과 큐와 달리 양방향으로 삽입/삭제가 자유롭다.
<br>
<br>
</li>
</ul>

<h3 id="stack과-queue의-차이점">Stack과 Queue의 차이점</h3>
<ul>
  <li>아이템을 삭제할 때 가장 큰 차이점이 있다.</li>
  <li>스택은 가장 마지막에 추가된 item을 삭제하고, 큐는 가장 처음 들어와있던 item을 삭제한다.</li>
  <li>스택과 큐 모두 Peek을 사용할 수 있다. Peak 연산은 자료구조의 변화를 주지 않고, pop이나 dequeue를 할 때 리턴되는 item을 리턴할 수 있다.
<br>
<br>
</li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li><a href="https://devuna.tistory.com/22">스택/큐 개념 비교/활용/예시</a></li>
  <li><a href="https://kwin0825.tistory.com/157">Queue 클래스 사용법 및 함수 정리</a></li>
</ul>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/wiki/2024/02/29/programmers-12906.html" title="프로그래머스 - 같은 숫자는 싫어 풀이">프로그래머스 - 같은 숫자는 싫어 풀이...</a><a class="next" href="/wiki/2024/03/17/string-replacement.html" title="문자열 대치">문자열 대치</a>
</div>
<div class="post-comments">  <div id="gisqus_thread"></div>
  <script src="https://giscus.app/client.js" data-repo="dajeongdev/dajeongdev.github.io" data-repo-id="R_kgDOHS7Ikw" data-category="General" data-category-id="DIC_kwDOHS7Ik84Cj70Z" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="ko" crossorigin="anonymous" async>
  let giscusAttributes = {
  src: "https://giscus.app/client.js",
  "data-repo": "da-in/da-in.github.io",
  "data-repo-id": "MDEwOlJlcG9zaXRvcnkzNTM5MDcyOTU=",
  "data-category": "General",
  "data-category-id": "DIC_kwDOFRgyX84CSEWg",
  "data-mapping": "pathname",
  "data-reactions-enabled": "1",
  "data-emit-metadata": "0",
  "data-theme": initTheme,
  "data-input-position":
    "bottom",
  "data-lang": "",
  crossorigin: "anonymous",
  async: "",
};

let giscusScript = document.createElement("script");
Object.entries(giscusAttributes).forEach(([key, value]) =>
  giscusScript.setAttribute(key, value)
);
document.getElementById("tail-wrapper").appendChild(giscusScript);
</script>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/blog/2024/05/10/book-service-admin-review.html" title="문자열 대치">독서 관리 서비스의 Admin 개발 회고</a></li>
<li><a class="post-link" href="/blog/2024/05/16/americanote-review.html" title="문자열 대치">비사이드 403 포텐데이 Americanote 회고</a></li>
<li><a class="post-link" href="/wiki/2023/11/13/array-slice-method.html" title="문자열 대치">배열 자르기</a></li>
<li><a class="post-link" href="/wiki/2024/04/29/americanote-server4-automatical-deploy.html" title="문자열 대치">아메리카노트 서버 구성 &lt;4&gt; 자동 배포</a></li>
</ul>
    </div>
  </section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
      <div>Copyright © 2024 @Dajeong Park</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="http://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
    </div>
  </div>
</footer>
</body>
</html>
