<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2023-12-30T17:35:09+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Every Single Day</title><subtitle></subtitle><author><name>Dajeong Park</name></author><entry><title type="html">hibernate6 custom function(MySQL Dialect)</title><link href="http://localhost:4000/wiki/2023/12/30/hibernate6-custom-function.html" rel="alternate" type="text/html" title="hibernate6 custom function(MySQL Dialect)" /><published>2023-12-30T00:00:00+09:00</published><updated>2023-12-30T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2023/12/30/hibernate6-custom-function</id><content type="html" xml:base="http://localhost:4000/wiki/2023/12/30/hibernate6-custom-function.html"><![CDATA[<h3 id="배경">배경</h3>
<p>현재 프로젝트에서 QueryDSL을 사용 중인데 여기에 집계함수를 사용하고 싶어서 사용자 함수 추가를 위해 서치 후 적용해보려고 했다. 그런데 이게 웬일.. Spring boot 3점대에서는 hibernate 6.1을 기본으로 사용하고 있어서 당장 올해 3월까지 올라온 블로그 글의 코드도 적용되지 않았다.. 그래서 한시간을 고생해서 적용해보고 고치고 하다가 김영한님 JPA 강의의 커뮤니티에 어떤 친절한 분이 해결방안을 올려주셨다.. 정말 천사,,</p>

<p><img src="https://dajeongdev.github.io/assets/images/posts/spring-boot-3.2-hibernate-version.png" />
<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M4-Release-Notes">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M4-Release-Notes</a>
<br />
<br /></p>

<h3 id="해결">해결</h3>
<ol>
  <li>FunctionContributor의 구현체를 만들어준다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomFunctionContributor</span> <span class="kd">implements</span> <span class="nc">FunctionContributor</span> <span class="o">{</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">contributeFunctions</span><span class="o">(</span><span class="nc">FunctionContributions</span> <span class="n">functionContributions</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">functionContributions</span><span class="o">.</span><span class="na">getFunctionRegistry</span><span class="o">()</span>
            <span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="s">"group_concat"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">StandardSQLFunction</span><span class="o">(</span><span class="s">"group_concat"</span><span class="o">,</span> <span class="nc">StandardBasicTypes</span><span class="o">.</span><span class="na">STRING</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>src/main/resources 하위에 META-INF/services/org.hibernate.boot.model.FunctionContributor 파일을 생성한다.</li>
  <li>
    <p>해당 파일에 1번의 구현체를 등록한다.</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">패키지명.구현체</code> 이름의 형태로 등록</li>
      <li>com.example.com.config.~Contributor
      -   yml 파일의 dialect 변경은 필요없음
<br /> <br />
<br /></li>
    </ul>
  </li>
</ol>

<h3 id="시도">시도</h3>
<ul>
  <li><a href="https://discourse.hibernate.org/t/migrate-hibernate-5-to-6-with-spring-boot-2-7-x-to-3/7787/2">https://discourse.hibernate.org/t/migrate-hibernate-5-to-6-with-spring-boot-2-7-x-to-3/7787/2</a></li>
  <li><a href="https://discourse.hibernate.org/t/migration-of-dialect-to-hibernate-6/6956/16">https://discourse.hibernate.org/t/migration-of-dialect-to-hibernate-6/6956/16</a></li>
  <li><a href="https://thisiswoo.github.io/development/using-jpa-querydsl-groupconcat-func.html">https://thisiswoo.github.io/development/using-jpa-querydsl-groupconcat-func.html</a>
<br />
<br /></li>
</ul>

<p><strong>참고</strong></p>
<ul>
  <li><a href="https://www.inflearn.com/questions/1096265/hibernate-6-custom-%ED%95%A8%EC%88%98-%EB%93%B1%EB%A1%9D-%EB%B0%A9%EB%B2%95-%EA%B3%B5%EC%9C%A0"></a><a href="https://www.inflearn.com/questions/1096265/hibernate-6-custom-%ED%95%A8%EC%88%98-%EB%93%B1%EB%A1%9D-%EB%B0%A9%EB%B2%95-%EA%B3%B5%EC%9C%A0">https://www.inflearn.com/questions/1096265/hibernate-6-custom-함수-등록-방법-공유</a></li>
  <li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M4-Release-Notes">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M4-Release-Notes</a></li>
  <li><a href="https://velog.io/@ttomy/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-dialectmatch-against%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0"></a><a href="https://velog.io/@ttomy/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-dialectmatch-against%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">https://velog.io/@ttomy/사용자-정의-dialectmatch-against사용하기</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Hibernate6" /><category term="MySQLDialect" /><category term="SpringBoot3" /><category term="QueryDSL" /><category term="JPQL" /><summary type="html"><![CDATA[배경 현재 프로젝트에서 QueryDSL을 사용 중인데 여기에 집계함수를 사용하고 싶어서 사용자 함수 추가를 위해 서치 후 적용해보려고 했다. 그런데 이게 웬일.. Spring boot 3점대에서는 hibernate 6.1을 기본으로 사용하고 있어서 당장 올해 3월까지 올라온 블로그 글의 코드도 적용되지 않았다.. 그래서 한시간을 고생해서 적용해보고 고치고 하다가 김영한님 JPA 강의의 커뮤니티에 어떤 친절한 분이 해결방안을 올려주셨다.. 정말 천사,,]]></summary></entry><entry><title type="html">List에서 원소 삭제하기 remove()</title><link href="http://localhost:4000/wiki/2023/11/21/list-remove-method.html" rel="alternate" type="text/html" title="List에서 원소 삭제하기 remove()" /><published>2023-11-21T00:00:00+09:00</published><updated>2023-11-21T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2023/11/21/list-remove-method</id><content type="html" xml:base="http://localhost:4000/wiki/2023/11/21/list-remove-method.html"><![CDATA[<h3 id="배경">배경</h3>
<p>코딩테스트로 문제를 풀다가 list에서 원소를 삭제하는 remove() 메소드를 사용할 때 값이 일치하면 삭제하고 싶은데 그냥 숫자를 넣으면 인덱스로 인식하는 것을 발견하였다. <br />
<br /></p>

<h3 id="integer-removeint-index">Integer remove(int index)</h3>
<ul>
  <li>파라미터를 int로 전달하면 해당 index의 값을 삭제한다. <br />
<br /></li>
</ul>

<h3 id="boolean-removeobject-o">boolean remove(Object o)</h3>
<ul>
  <li>파라미터로 Object 객체를 전달하면, List에서 해당 객체를 찾아서 <strong>첫번째</strong>로 나오는 값을 삭제한 뒤 값을 삭제하는 데 성공하면 <strong>true</strong>, 값이 없으면 <strong>false</strong>를 리턴한다.</li>
  <li><strong>예시</strong> (프로그래머스 level 0 배열에서 원소 삭제하기)
    <ul>
      <li><a href="https://school.programmers.co.kr/learn/courses/30/lessons/181844">https://school.programmers.co.kr/learn/courses/30/lessons/181844</a>
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">delete_list</span><span class="o">)</span> <span class="o">{</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">).</span><span class="na">boxed</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">delete_list</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
<span class="k">if</span> <span class="o">(</span><span class="n">answer</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">delete_list</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span>
        <span class="n">answer</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">delete_list</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span> <span class="c1">// (Integer)으로 형변환도 가능</span>
<span class="k">return</span> <span class="n">answer</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>그래서 위처럼 Object로 인식할 수 있도록 <strong>Wrapper 클래스로(여기선 Integer) 형변환해주는 방법</strong>이 있다.</li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="List" /><category term="Method" /><summary type="html"><![CDATA[배경 코딩테스트로 문제를 풀다가 list에서 원소를 삭제하는 remove() 메소드를 사용할 때 값이 일치하면 삭제하고 싶은데 그냥 숫자를 넣으면 인덱스로 인식하는 것을 발견하였다.]]></summary></entry><entry><title type="html">문자열 자르기</title><link href="http://localhost:4000/wiki/2023/11/13/cut-string-method.html" rel="alternate" type="text/html" title="문자열 자르기" /><published>2023-11-13T00:00:00+09:00</published><updated>2023-11-13T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2023/11/13/cut-string-method</id><content type="html" xml:base="http://localhost:4000/wiki/2023/11/13/cut-string-method.html"><![CDATA[<h3 id="1-stringsplit">1. String.split()</h3>
<ul>
  <li>지정한 구분자(정규표현식)로 문자열을 나눠 문자열 배열에 저장한다.</li>
  <li>공백 포함 <br />
<br /></li>
</ul>

<h3 id="2-stringtokenizer">2. StringTokenizer</h3>
<ul>
  <li>지정한 구분자(문자열)로 문자열을 나눈다.</li>
  <li>구분자 생략 시 공백이 디폴트</li>
  <li><strong>생성자</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringTokenizer</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="c1">// 공백 구분자 사용</span>
<span class="nc">StringTokenizer</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">,</span> <span class="nc">String</span> <span class="n">delim</span><span class="o">)</span> <span class="c1">// 구분자 지정</span>
<span class="nc">StringTokenizer</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">,</span> <span class="nc">String</span> <span class="n">delim</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">returnDelims</span><span class="o">)</span> <span class="c1">// 구분자도 토큰에 포함</span>
</code></pre></div></div>
<ul>
  <li><strong>메소드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nextToken</span><span class="o">()</span>     <span class="c1">// 다음 토큰 반환 (이전 토큰은 삭제)</span>
<span class="n">hasMoreTokens</span><span class="o">()</span> <span class="c1">// 리턴할 토큰이 남아있으면 true, 없으면 false</span>
<span class="n">countTokens</span><span class="o">()</span>   <span class="c1">// 남아있는 토큰의 갯수</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="공통점">공통점</h4>
<ul>
  <li>지정한 구분자를 통해 문자열을 나눈다. <br />
<br /></li>
</ul>

<h4 id="차이점">차이점</h4>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>String.split()</th>
      <th>StringTokenizer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>구분자</td>
      <td>정규표현식</td>
      <td>문자/문자열</td>
    </tr>
    <tr>
      <td>빈 문자열 인식</td>
      <td>O</td>
      <td>X</td>
    </tr>
    <tr>
      <td>결과값</td>
      <td>String[]</td>
      <td>StringTokenizer → 반복문으로 출력 가능</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="Method" /><summary type="html"><![CDATA[1. String.split() 지정한 구분자(정규표현식)로 문자열을 나눠 문자열 배열에 저장한다. 공백 포함]]></summary></entry><entry><title type="html">default method</title><link href="http://localhost:4000/wiki/2023/11/13/default-method.html" rel="alternate" type="text/html" title="default method" /><published>2023-11-13T00:00:00+09:00</published><updated>2023-11-13T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2023/11/13/default-method</id><content type="html" xml:base="http://localhost:4000/wiki/2023/11/13/default-method.html"><![CDATA[<h3 id="기존의-인터페이스">기존의 인터페이스</h3>
<p>기존의 인터페이스는 추상 메서드만 존재할 수 있고, 이를 상속 받는 구현체에서 직접 해당 추상 메소드를 구현해야 한다. 
이는 인터페이스에 메서드가 추가되면 그 인터페이스를 상속 받는 모든 구현체 클래스에 추가 메서드를 구현해주어야 하는 문제가 발생한다.
이 경우 <strong>확장(open)은 할 수 있지만, 변경에 대한 폐쇄(close)는 위반했다</strong>고 할 수 있다. (객체 지향의 원칙 중 OCP) 
<strong>새로운 메소드가 인터페이스에 추가된다는 이유로 새로운 메소드를 사용하지 않는 구현체에도 추가적으로 구현을 해야 하기 때문</strong>이다. 즉, 기존의 코드가 변경되어버린다. <br />
<br /></p>

<h3 id="default-method">default method</h3>
<p>JAVA 8부터 추가된 default method를 통해 인터페이스에서도 메소드를 구현할 수 있게 되었다.
인터페이스에 default 메소드를 추가해도 구현체에 추가적인 변경을 하지 않기 때문에 <strong>기존 구현체의 코드 변경 없이 확장할 수 있게 된 것</strong> 이다.
<br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TestInterface</span> <span class="o">{</span>
		<span class="kt">void</span> <span class="nf">testAbstractMethod1</span><span class="o">();</span>
		<span class="kt">void</span> <span class="nf">testAbstractMethod2</span><span class="o">();</span>

		<span class="k">default</span> <span class="nc">String</span> <span class="nf">defaultMethod1</span><span class="o">()</span> <span class="o">{</span>
				<span class="c1">// 구현 코드</span>
		<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="추가">추가</h3>
<p>자바 8부터는 이전 버전과는 다르게 추상 클래스를 그렇게 많이 쓰지 않고, 추상 클래스가 하던 일을 많은 부분 인터페이스가 하게 되었기 때문에 정말 필요한 경우가 아니라면 인터페이스에 있는 default 메소드를 사용해서 시도해보는 것이 좋다.
<br />
<br /></p>

<h2 id="참고">참고</h2>
<ul>
  <li><a href="https://velog.io/@heoseungyeon%EB%94%94%ED%8F%B4%ED%8A%B8-%EB%A9%94%EC%84%9C%EB%93%9CDefault-Method">https://velog.io/@heoseungyeon/디폴트-메서드Default-Method</a></li>
  <li><a href="https://www.inflearn.com/course/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/dashboard">https://www.inflearn.com/course/디자인-패턴/dashboard</a>
```</li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="Java8" /><summary type="html"><![CDATA[기존의 인터페이스 기존의 인터페이스는 추상 메서드만 존재할 수 있고, 이를 상속 받는 구현체에서 직접 해당 추상 메소드를 구현해야 한다. 이는 인터페이스에 메서드가 추가되면 그 인터페이스를 상속 받는 모든 구현체 클래스에 추가 메서드를 구현해주어야 하는 문제가 발생한다. 이 경우 확장(open)은 할 수 있지만, 변경에 대한 폐쇄(close)는 위반했다고 할 수 있다. (객체 지향의 원칙 중 OCP) 새로운 메소드가 인터페이스에 추가된다는 이유로 새로운 메소드를 사용하지 않는 구현체에도 추가적으로 구현을 해야 하기 때문이다. 즉, 기존의 코드가 변경되어버린다.]]></summary></entry><entry><title type="html">자바로 피보나치 수열 이해하기</title><link href="http://localhost:4000/wiki/2023/11/13/fibonacci.html" rel="alternate" type="text/html" title="자바로 피보나치 수열 이해하기" /><published>2023-11-13T00:00:00+09:00</published><updated>2023-11-13T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2023/11/13/fibonacci</id><content type="html" xml:base="http://localhost:4000/wiki/2023/11/13/fibonacci.html"><![CDATA[<ul>
  <li>피보나치 수열은 재귀 함수의 대표적인 예시로, 첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열이다.
    <ul>
      <li>F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2)</li>
      <li><strong>재귀 함수</strong>: 자기 자신을 다시 호출해 작업을 수행하는 함수</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>			
			<span class="k">return</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
		<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="프로그래머스-피보나치-수-풀이">프로그래머스 피보나치 수 풀이</h3>

<h4 id="원래-코드">원래 코드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">answer</span> <span class="o">=</span> <span class="o">(</span><span class="n">first</span> <span class="o">+</span> <span class="n">second</span><span class="o">);</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">second</span><span class="o">;</span>
			<span class="n">second</span> <span class="o">=</span> <span class="n">answer</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
	<span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>이 코드를 제출했더니 7번부터 오답이 나왔다.. 그래서 한참 고민하다가 질문하기 페이지를 봤는데 좋은 답변을 달아주셔서 참고했다.
  <img src="https://dajeongdev.github.io/assets/images/posts/fibonacci-reference.png" />
    <ul>
      <li><strong>정리</strong>: 자료형의 크기에 제한이 있는 언어를 사용할 경우 (A + B) % C == ((A % C) + (B % C)) % C라는 모듈러 연산의 성질을 이용하여, 계산 결과에 1234567으로 나눈 나머지를 대신 넣는 것으로 int 범위 내에 항상 값이 존재하도록 보장할 수 있다. <br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="수정-코드">수정 코드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">answer</span> <span class="o">=</span> <span class="o">(</span><span class="n">first</span> <span class="o">+</span> <span class="n">second</span><span class="o">)</span> <span class="o">%</span> <span class="mi">1234567</span><span class="o">;</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">second</span><span class="o">;</span>
			<span class="n">second</span> <span class="o">=</span> <span class="n">answer</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
	<span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="Algorithm" /><summary type="html"><![CDATA[피보나치 수열은 재귀 함수의 대표적인 예시로, 첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열이다. F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 재귀 함수: 자기 자신을 다시 호출해 작업을 수행하는 함수]]></summary></entry><entry><title type="html">IntelliJ 단축키 정리</title><link href="http://localhost:4000/wiki/2023/11/13/intellij-shortcut.html" rel="alternate" type="text/html" title="IntelliJ 단축키 정리" /><published>2023-11-13T00:00:00+09:00</published><updated>2023-11-13T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2023/11/13/intellij-shortcut</id><content type="html" xml:base="http://localhost:4000/wiki/2023/11/13/intellij-shortcut.html"><![CDATA[<table>
  <thead>
    <tr>
      <th>설명</th>
      <th>단축키</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>이름 변경(Rename)</td>
      <td>Shift + F6</td>
    </tr>
    <tr>
      <td>접근제어자, 반환타입, 이름등 주요 정보 변경</td>
      <td>Ctrl + F6</td>
    </tr>
    <tr>
      <td>한 줄 복사</td>
      <td>Ctrl + D</td>
    </tr>
    <tr>
      <td>Inline</td>
      <td>Ctrl + Alt + N</td>
    </tr>
    <tr>
      <td>메소드 추출</td>
      <td>Ctrl + Alt + M</td>
    </tr>
    <tr>
      <td>변수 추출</td>
      <td>Ctrl + Alt + V</td>
    </tr>
    <tr>
      <td>Generate 탭 열기 (Constructor, Getter/Setter, Override 등)</td>
      <td>Alt + Insert</td>
    </tr>
    <tr>
      <td>implement methods / static import  / change lamda expression</td>
      <td>Alt + Enter</td>
    </tr>
    <tr>
      <td>이전 실행 메소드 재실행</td>
      <td>Shift + F10</td>
    </tr>
    <tr>
      <td>현재 커서 메소드 실행</td>
      <td>Ctrl + Shift + F10</td>
    </tr>
    <tr>
      <td>코드 정렬</td>
      <td>Ctrl + Alt + L</td>
    </tr>
    <tr>
      <td>import 정리</td>
      <td>Ctrl + Alt + O</td>
    </tr>
    <tr>
      <td>for</td>
      <td>fori</td>
    </tr>
    <tr>
      <td>for each문 생성</td>
      <td>iter</td>
    </tr>
    <tr>
      <td>System.out.println</td>
      <td>sout</td>
    </tr>
    <tr>
      <td>System.out.println + 가까운 변수</td>
      <td>soutv</td>
    </tr>
    <tr>
      <td>System.out.println + 메서드</td>
      <td>soutm</td>
    </tr>
    <tr>
      <td>public static void main</td>
      <td>psvm</td>
    </tr>
    <tr>
      <td>public static final</td>
      <td>psf</td>
    </tr>
    <tr>
      <td>private static final</td>
      <td>prsf</td>
    </tr>
    <tr>
      <td>throw new</td>
      <td>thr</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="IDE" /><category term="IntelliJ" /><summary type="html"><![CDATA[설명 단축키 이름 변경(Rename) Shift + F6 접근제어자, 반환타입, 이름등 주요 정보 변경 Ctrl + F6 한 줄 복사 Ctrl + D Inline Ctrl + Alt + N 메소드 추출 Ctrl + Alt + M 변수 추출 Ctrl + Alt + V Generate 탭 열기 (Constructor, Getter/Setter, Override 등) Alt + Insert implement methods / static import / change lamda expression Alt + Enter 이전 실행 메소드 재실행 Shift + F10 현재 커서 메소드 실행 Ctrl + Shift + F10 코드 정렬 Ctrl + Alt + L import 정리 Ctrl + Alt + O for fori for each문 생성 iter System.out.println sout System.out.println + 가까운 변수 soutv System.out.println + 메서드 soutm public static void main psvm public static final psf private static final prsf throw new thr]]></summary></entry><entry><title type="html">Dangling meta character ‘?’ near index 0</title><link href="http://localhost:4000/wiki/2023/11/13/java-regex-pattern-syntax-error.html" rel="alternate" type="text/html" title="Dangling meta character ‘?’ near index 0" /><published>2023-11-13T00:00:00+09:00</published><updated>2023-11-13T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2023/11/13/java-regex-pattern-syntax-error</id><content type="html" xml:base="http://localhost:4000/wiki/2023/11/13/java-regex-pattern-syntax-error.html"><![CDATA[<h3 id="에러">에러</h3>
<p><img src="https://dajeongdev.github.io/assets/images/posts/java-regex-pattern-syntax-error.png" alt="error_image" />
<br /></p>

<h3 id="코드">코드</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">split</span> <span class="o">=</span> <span class="n">question</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"?"</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="원인">원인</h3>
<ul>
  <li>split() 메소드 사용시 특정한 문자를 regex로 사용하는 경우 동작하지 않는다.
  * 특정한 문자: 이미 문법 상 사용 중인 특수문자 (|, &amp;, ^, *, ?, . 등) <br />
<br /></li>
</ul>

<h3 id="해결-방법">해결 방법</h3>
<ul>
  <li>regex 앞에 <strong>백슬래시(\)</strong>를 <strong>두 번</strong> 넣어주면 코드가 정상적으로 동작한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">split</span> <span class="o">=</span> <span class="n">question</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\?"</span><span class="o">);</span>
</code></pre></div></div>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="Error" /><summary type="html"><![CDATA[에러]]></summary></entry><entry><title type="html">Map - getOrDefault(Object key, V defaultValue)</title><link href="http://localhost:4000/wiki/2023/11/13/map-getOrDefault.html" rel="alternate" type="text/html" title="Map - getOrDefault(Object key, V defaultValue)" /><published>2023-11-13T00:00:00+09:00</published><updated>2023-11-13T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2023/11/13/map-getOrDefault</id><content type="html" xml:base="http://localhost:4000/wiki/2023/11/13/map-getOrDefault.html"><![CDATA[<h3 id="map---getordefaultobject-key-v-defaultvalue">Map - getOrDefault(Object key, V defaultValue)</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">V</span> <span class="nf">getOrDefault</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">defaultValue</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
		<span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">defaultValue</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>key가 존재하면 key의 value를 반환하고, 없으면 설정한 디폴트 값을 반환한다. <br />
<br /></li>
</ul>

<h4 id="사용-예시-프로그래머스-level-2-위장">사용 예시 (프로그래머스 level 2 위장)</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[][]</span> <span class="n">clothes1</span> <span class="o">=</span> <span class="o">/{/{</span><span class="s">"yellow_hat"</span><span class="o">,</span> <span class="s">"headgear"</span><span class="o">/},</span> 
			<span class="o">/{</span><span class="s">"blue_sunglasses"</span><span class="o">,</span> <span class="s">"eyewear"</span><span class="o">/},</span> 
			<span class="o">/{</span><span class="s">"green_turban"</span><span class="o">,</span> <span class="s">"headgear"</span><span class="o">/}/};</span>
<span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">clothes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">clothes</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">clothes</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>HashMap은 동일한 key에 value를 추가할 경우 value가 덮어쓰기 되기 때문에 getOrDefault() 메소드를 사용하여 예시처럼 카운트를 추가하는 등의 방법을 사용할 수 있다.</li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="Map" /><category term="Method" /><summary type="html"><![CDATA[Map - getOrDefault(Object key, V defaultValue) public V getOrDefault(Object key, V defaultValue) { Node&lt;K,V&gt; e; return (e = getNode(key)) == null ? defaultValue : e.value; } key가 존재하면 key의 value를 반환하고, 없으면 설정한 디폴트 값을 반환한다.]]></summary></entry><entry><title type="html">MyBatis와 JPA</title><link href="http://localhost:4000/wiki/2023/11/13/mybatis-jpa.html" rel="alternate" type="text/html" title="MyBatis와 JPA" /><published>2023-11-13T00:00:00+09:00</published><updated>2023-11-13T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2023/11/13/mybatis-jpa</id><content type="html" xml:base="http://localhost:4000/wiki/2023/11/13/mybatis-jpa.html"><![CDATA[<p>먼저 MyBatis와 JPA를 알아보기 전에 알아두면 좋은 두 개념을 살펴보자.</p>
<h4 id="sql-mapper">SQL Mapper</h4>
<p>SQL Mapper는 직접 작성한 SQL에 해당되는 데이터를 읽고, 결과값을 객체화시켜 사용할 수 있게 해준다. SQL에 데이터베이스에 따라 SQL 문법이 다르므로 특정 RDB에 종속적이며, SQL에 의존적인 개발하게 된다.</p>
<ul>
  <li>예) MyBatis</li>
</ul>

<h4 id="ormobject-relational-mapping">ORM(Object-Relational Mapping)</h4>
<p>ORM은 객체는 객체대로 설계하고, 관계형 데이터베이스(RDB)는 관계형 데이터베이스대로 설계 후 ORM이 중간에서 매핑해주는 것을 의미한다. SQL이 아닌 관계형 데이터베이스에 데이터 자체를 매핑하기 때문에 SQL을 직접 작성할 필요가 없다.
이로 인해 특정 데이터베이스에 구애받지 않으며, 제공하는 메서드와 코드 또한 직관적이어서 사용하기 편리하다.</p>
<ul>
  <li>예) Hibernate, JPA 등 <br />
<br /></li>
</ul>

<hr />
<h3 id="mybatisjava-persistence-framework">MyBatis(Java Persistence Framework)</h3>
<p>MyBatis는 SQL Mapper의 일종으로 개발자가 지정한 SQL, 저장 프로시저 그리고 몇 가지 고급 매핑을 지원하는 영속성 프레임워크다. MyBatis는 JDBC로 처리하는 상당 부분의 코드와 파라미터 설정 및 결과 매핑을 대신해주고, 데이터베이스 record에 원시 타입과 Map 그리고 Java POJO를 설정하여 매핑하기 위해 XML과 Annotation을 사용할 수 있다. 즉, SQL문을 직접 작성하여 객체와 매핑시켜준다.</p>

<h4 id="장점">장점</h4>
<ul>
  <li>SQL 쿼리를 직접 작성하므로 최적화된 쿼리를 구현할 수 있다.</li>
  <li>SQL의 세부적인 내용 변경이나 동적 쿼리 사용 시 JPA보다 간편하게 구현 가능하다.</li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>쿼리를 직접 작성하기 때문에 데이터베이스 변경 시 수정할 부분이 굉장히 많아진다. (특정 데이터베이스에 종속적이다)</li>
  <li>런타임 시 에러를 발견할 수 있다.</li>
  <li>비슷한 코드를 반복적으로 작업하게 된다.</li>
</ul>

<p><br /></p>

<hr />
<h3 id="jpajava-persistence-api">JPA(Java Persistence API)</h3>
<p>JPA는 Java ORM의 기술 표준에 대한 API 표준 명세로, 객체와 데이터베이스의 패러다임 불일치로 인한 문제점을 해결하기 위해 등장했다. 개발자는 객체지향적인 개발을 하고, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성해서 실행하기 때문에 SQL에 종속적인 개발이 아닌 객체 중심 개발을 할 수 있다.
JPA는 인터페이스이기 때문에, 구현체로는 Hibernate, EclipseLink, DataNucleus 등이 있다. Spring에서 JPA를 사용할 땐 이 구현체들을 직접 다루는게 아니라 좀 더 쉽게 사용하기 위해 추상화시킨 Spring Data JPA를 사용한다. 덕분에 관계형 데이터베이스 외에 다른 저장소로 쉽게 교체할 수 있다. (예: Spring Data JPA -&gt; Spring Data MongoDB)</p>

<h4 id="장점-1">장점</h4>
<ul>
  <li>객체 중심 개발을 하기 때문에 생산성이 향상되고, 유지보수 또한 편하다.</li>
  <li>컴파일 시에 에러를 발견할 수 있다.</li>
</ul>

<h4 id="단점-1">단점</h4>
<ul>
  <li>객체지향과 관계형 데이터베이스 둘 다 이해해야 하기 때문에 러닝 커브가 높다.</li>
</ul>

<p><br /></p>

<hr />
<h4 id="개인적인-의견">개인적인 의견</h4>
<p>요즘엔 QueryDsl 같은 조회용 프레임워크를 함께 사용하여 복잡한 연산도 깔끔하게 할 수 있다. 개인적으로 자바 개발자라면 한 번쯤 꼭 배워보는게 좋다고 생각하며, 언젠가는 꼭 실무에서 JPA를 사용해보고 싶다!</p>

<hr />
<h4 id="참고">참고</h4>
<ul>
  <li><a href="https://mybatis.org/mybatis-3/ko/index.html">https://mybatis.org/mybatis-3/ko/index.html</a></li>
  <li><a href="https://dreaming-soohyun.tistory.com/entry/JPA%EC%99%80-MyBatis%EC%9D%98-%EC%B0%A8%EC%9D%B4-ORM%EA%B3%BC-SQL-Mapper">https://dreaming-soohyun.tistory.com/entry/JPA%EC%99%80-MyBatis%EC%9D%98-%EC%B0%A8%EC%9D%B4-ORM%EA%B3%BC-SQL-Mapper</a></li>
  <li><a href="https://incheol-jung.gitbook.io/docs/q-and-a/spring/jpa-vs-mybatis">https://incheol-jung.gitbook.io/docs/q-and-a/spring/jpa-vs-mybatis</a></li>
  <li>이동욱님의 책 [스프링 부트와 AWS로 혼자 구현하는 웹 서비스]</li>
  <li>김영한님의 인프런 강의 [실전! 스프링 부트와 JPA 활용 시리즈] <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-%ED%99%9C%EC%9A%A9-1">https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-%ED%99%9C%EC%9A%A9-1</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Spring" /><category term="MyBatis" /><category term="JPA" /><summary type="html"><![CDATA[먼저 MyBatis와 JPA를 알아보기 전에 알아두면 좋은 두 개념을 살펴보자. SQL Mapper SQL Mapper는 직접 작성한 SQL에 해당되는 데이터를 읽고, 결과값을 객체화시켜 사용할 수 있게 해준다. SQL에 데이터베이스에 따라 SQL 문법이 다르므로 특정 RDB에 종속적이며, SQL에 의존적인 개발하게 된다. 예) MyBatis]]></summary></entry><entry><title type="html">MySQL IN</title><link href="http://localhost:4000/wiki/2023/11/13/mysql-in.html" rel="alternate" type="text/html" title="MySQL IN" /><published>2023-11-13T00:00:00+09:00</published><updated>2023-11-13T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2023/11/13/mysql-in</id><content type="html" xml:base="http://localhost:4000/wiki/2023/11/13/mysql-in.html"><![CDATA[<h3 id="개념">개념</h3>
<ul>
  <li>여러 값을 OR 관계로 묶어서 나열하는 조건을 WHERE 절에 사용할 때 쓸 수 있는 키워드</li>
  <li>IN 연산자는 조건의 범위를 지정하는 데 사용된다.</li>
  <li>값은 콤마(,)로 구분하여 괄호 내에 묶고, 이 값 중에서 하나 이상과 일치하면 조건에 맞는 것으로 평가된다. <br />
<br /></li>
</ul>

<h3 id="예시">예시</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- OR 조건 표현</span>
<span class="k">where</span> <span class="n">condition</span> <span class="o">=</span> <span class="nv">"A"</span> <span class="k">or</span> <span class="n">condition</span> <span class="o">=</span> <span class="nv">"B"</span><span class="p">;</span>

<span class="c1">-- IN 조건</span>
<span class="k">where</span> <span class="n">condition</span> <span class="k">in</span> <span class="p">(</span><span class="nv">"A"</span><span class="p">,</span> <span class="nv">"B"</span><span class="p">);</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="장점">장점</h3>
<ul>
  <li>목록에 넣을 값이 여러 개일 때, IN 연산자가 OR 연산자 보다 쓰기도, 보기도, 이해하기도 쉽다.</li>
  <li>IN을 사용하면 조건 순서를 보다 쉽게 관리할 수 있고, 연산자의 수도 줄어든다.</li>
  <li>IN 연산자가 OR 연산자 보다 실행 속도가 빠르다.</li>
  <li>IN 연산자 안에 다른 SELECT문(서브 쿼리)를 넣을 수 있다. <br />
<br /></li>
</ul>

<h1 id="참고">참고</h1>
<ul>
  <li><a href="https://velog.io/@inyong_pang/MySQL-IN-%EC%A1%B0%EA%B1%B4"></a><a href="https://velog.io/@inyong_pang/MySQL-IN-%EC%A1%B0%EA%B1%B4">https://velog.io/@inyong_pang/MySQL-IN-조건</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="SQL" /><category term="MySQL" /><summary type="html"><![CDATA[개념 여러 값을 OR 관계로 묶어서 나열하는 조건을 WHERE 절에 사용할 때 쓸 수 있는 키워드 IN 연산자는 조건의 범위를 지정하는 데 사용된다. 값은 콤마(,)로 구분하여 괄호 내에 묶고, 이 값 중에서 하나 이상과 일치하면 조건에 맞는 것으로 평가된다.]]></summary></entry></feed>