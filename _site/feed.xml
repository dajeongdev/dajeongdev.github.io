<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2024-11-23T18:06:38+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Every Single Day</title><subtitle></subtitle><author><name>Dajeong Park</name></author><entry><title type="html">Spring Boot에서 국제화로 언어 장벽 허물기!</title><link href="http://localhost:4000/wiki/2024/11/23/spring-internationalization.html" rel="alternate" type="text/html" title="Spring Boot에서 국제화로 언어 장벽 허물기!" /><published>2024-11-23T00:00:00+09:00</published><updated>2024-11-23T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/11/23/spring-internationalization</id><content type="html" xml:base="http://localhost:4000/wiki/2024/11/23/spring-internationalization.html"><![CDATA[<h3 id="배경">배경</h3>
<p>최근 회사에서 진행하는 프로젝트가 글로벌 사용자를 타겟으로 두고 있어서 다국어 처리를 사용해 보게 되었는데요, 이에 대해 제가 알아본 방법과 작업하고 있는 방법을 정리해보겠습니다.
<br />
<br /></p>

<h3 id="spring에서의-다국어-처리국제화">Spring에서의 다국어 처리(국제화)</h3>
<p>Spring에서는 다국어 처리에 대해 국제화라는 기능을 제공하고 있습니다. messages.properties 파일의 messages라는 이름 뒤에 Locale만 붙이면 내부에서 해당 파일을 찾아 처리해 줍니다.</p>

<p><strong>messages_ko.properties</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">greeting</span><span class="o">=</span><span class="n">안녕하세요</span>
<span class="n">greeting_name</span><span class="o">=</span><span class="n">안녕하세요</span><span class="o">,</span> <span class="o">{</span><span class="mi">0</span><span class="o">}</span><span class="n">님</span>
</code></pre></div></div>

<p><strong>messages_en.properties</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">greeting</span><span class="o">=</span><span class="n">hello</span>
<span class="n">greeting_name</span><span class="o">=</span><span class="n">hello</span><span class="o">,</span> <span class="o">{</span><span class="mi">0</span><span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="locale">Locale</h4>
<p>위에서 사용하는 로케일이란 무엇일까요? 로케일은 컴퓨터 시스템에서 특정 지역이나 문화권에 맞는 설정을 정의하는 개념으로, 주로 언어, 국가, 날짜와 시간 형식, 숫자 형식, 통화, 정렬 순서 등과 같은 지역화(Localization) 정보를 포함합니다.</p>

<p><strong>Locale 표기 방식 (UNIX/LINUX 시스템)</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">language</span><span class="o">[</span><span class="n">_territory</span><span class="o">][.</span><span class="na">codeset</span><span class="o">][</span><span class="nd">@modifier</span><span class="o">]</span>
</code></pre></div></div>

<p>한국어를 사용하는 경우 ko_KR.UTF-8을 주로 사용합니다. ko는 한국어, KR은 지역을 의미하고, 코드셋에는 UTF-8이나 EUC-KR 같은 인코딩 타입을 지정해 줍니다.<br />
일반적으로는 추가 문자열을 의미하는 @modifier 없이 언어, 지역, 코드셋 3개의 값으로 형성된 하나의 로케일을 사용합니다.
<br />
<br /></p>

<h2 id="설정-방법">설정 방법</h2>

<h4 id="1-applicationymlproperties">1. application.yml(properties)</h4>
<p>그래서 Spring에서 messages 파일을 어떻게 인식하는 걸까요? 기존에는 MessageSource를 직접 Bean으로 등록해야 했습니다. 그러나 SpringBoot에서는 따로 등록할 필요 없이 설정 파일(properties/yml)에서 설정할 수 있습니다. 이렇게 설정해두면 자동으로 <code class="language-plaintext highlighter-rouge">messages_*.properties</code>의 형식으로 추가한 파일들을 인식합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">spring:</span>
  <span class="nl">messages:</span>
    <span class="nl">basename:</span> <span class="n">messages</span><span class="o">/</span><span class="n">messages</span> <span class="err">#</span> <span class="n">메시지</span> <span class="n">파일명</span><span class="o">,</span> <span class="k">default</span> <span class="n">messages</span>
    <span class="nl">encoding:</span> <span class="no">UTF</span><span class="o">-</span><span class="mi">8</span> <span class="err">#</span> <span class="n">인코딩</span> <span class="n">설정</span>
    <span class="n">always</span><span class="o">-</span><span class="n">use</span><span class="o">-</span><span class="n">message</span><span class="o">-</span><span class="nl">format:</span> <span class="kc">false</span> <span class="err">#</span> <span class="n">시스템</span> <span class="n">로케일로</span> <span class="n">fallback</span> <span class="n">하지</span> <span class="n">않도록</span> <span class="n">설정</span>
</code></pre></div></div>

<h4 id="2localeinterceptor">2.LocaleInterceptor</h4>
<p>현재 프로젝트에서는 경로에서 locale을 받아오기 때문에 로케일이 포함된 경로일 경우 로케일을 읽어 프로젝트의 기본 로케일로 설정해주고 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocaleInterceptor</span> <span class="kd">implements</span> <span class="nc">HandlerInterceptor</span> <span class="o">{</span>

    <span class="nd">@Getter</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">includePatterns</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/api/**"</span><span class="o">};</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">requestURI</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">();</span>
        <span class="c1">// URL에서 locale 추출</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">pathSegments</span> <span class="o">=</span> <span class="n">requestURI</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"/"</span><span class="o">);</span>

        <span class="c1">// locale이 포함된 경로가 /api/{locale}/... 일 때</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pathSegments</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">localeStr</span> <span class="o">=</span> <span class="n">pathSegments</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>

            <span class="c1">// locale이 유효한 형식일 때만 설정</span>
            <span class="nc">Locale</span> <span class="n">locale</span> <span class="o">=</span> <span class="nc">Locale</span><span class="o">.</span><span class="na">forLanguageTag</span><span class="o">(</span><span class="n">localeStr</span><span class="o">);</span>
            <span class="nc">Locale</span><span class="o">.</span><span class="na">setDefault</span><span class="o">(</span><span class="n">locale</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>🔼 그런데 지금 생각해보니 이렇게 처리하는 것보다 AcceptLanguage로 받는 게 더 낫지 않았을까 하는 생각이 듭니다. 프로젝트가 이미 어느 정도 진행 중이라 바꾸기 쉽지 않겠지만, 시도는 해보겠습니다.
<br /></p>

<h4 id="3-securityconfig">3. SecurityConfig</h4>
<p>작업한 환경에 따라 다르겠지만, 프로젝트에서 토큰을 사용 중이기 때문에 SecurityConfig에 2번에서 설정한 인터셉터를 추가해주었습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@EnableWebSecurity</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityConfig</span> <span class="kd">implements</span> <span class="nc">WebMvcConfigurer</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">LocaleInterceptor</span> <span class="n">localeInterceptor</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addInterceptors</span><span class="o">(</span><span class="nc">InterceptorRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 다국어 인터셉터</span>
    <span class="n">registry</span><span class="o">.</span><span class="na">addInterceptor</span><span class="o">(</span><span class="n">localeInterceptor</span><span class="o">).</span>
        <span class="n">addPathPatterns</span><span class="o">(</span><span class="n">localeInterceptor</span><span class="o">.</span><span class="na">getIncludePatterns</span><span class="o">());</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="4-controllerservice">4. Controller/Service</h4>
<p>저희 프로젝트에서는 다국어를 에러 메세지 위주로 사용하기 때문에 Service단에서 사용했는데요, 이또한 작업 환경에 따라 Controller에서도 사용할 수도 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="no">EXISTING_EMAIL</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">locale</span><span class="o">);</span>
<span class="n">messageSource</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="no">EXISTING_EMAIL</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="s">"name"</span><span class="o">},</span> <span class="n">locale</span><span class="o">);</span> <span class="c1">// 동적 메세지 사용</span>
</code></pre></div></div>

<p>보통 code, args, locale 세 가지의 파라미터를 사용한 getMessage() 메소드를 사용했습니다.</p>

<ul>
  <li><strong>code</strong>: messages에 key 값으로 넣어둔 문자열</li>
  <li><strong>args</strong>: 동적 메세지를 사용하고 싶은 경우 값을 넣을 Object 배열</li>
  <li><strong>locale</strong>: 프론트로부터 받거나 기본적으로 설정된 locale
<br />
<br /></li>
</ul>

<h4 id="마무리">마무리</h4>
<p>Spring에 대해 공부할 때부터 한 번쯤 제대로 경험해보고 싶었던 국제화 기능에 대해 자세히 알아보고 실무에서 바로 사용해보니 정말 재미있었습니다. 강력한 SpringBoot 덕분에 많은 설정 없이 원하는 언어별로 제공할 수 있네요.
<br />
<br /></p>

<h4 id="참고">참고</h4>
<ul>
  <li><a href="https://velog.io/@maketheworldwise/%EB%8B%A4%EA%B5%AD%EC%96%B4-%EC%B2%98%EB%A6%AC%EC%9D%98-%EB%AA%A8%EB%93%A0-%EA%B2%83">다국어 처리의 모든 것</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Spring" /><category term="SpringBoot" /><category term="Internationalization" /><category term="Message" /><category term="글또" /><category term="글또10기" /><summary type="html"><![CDATA[배경 최근 회사에서 진행하는 프로젝트가 글로벌 사용자를 타겟으로 두고 있어서 다국어 처리를 사용해 보게 되었는데요, 이에 대해 제가 알아본 방법과 작업하고 있는 방법을 정리해보겠습니다.]]></summary></entry><entry><title type="html">Validation 그거 어떻게 하는건데</title><link href="http://localhost:4000/wiki/2024/10/27/spring-validation.html" rel="alternate" type="text/html" title="Validation 그거 어떻게 하는건데" /><published>2024-10-27T00:00:00+09:00</published><updated>2024-10-27T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/10/27/spring-validation</id><content type="html" xml:base="http://localhost:4000/wiki/2024/10/27/spring-validation.html"><![CDATA[<h3 id="배경">배경</h3>
<p>백엔드 작업에서 Validation은 꽤나 중요도가 높은 작업으로, 클라이언트가 보내는 데이터가 서버에서 기대하는 형식과 규칙을 충족하는지 확인하는 과정을 의미합니다. 
주로 웹 애플리케이션에서 클라이언트가 API를 통해 데이터를 전송할 때 백엔드에서는 이 데이터가 정확한지, 요구사항을 만족하는지 검증을 해야 데이터베이스에 저장하거나 다음 처리를 진행하게 됩니다.
<br />
<br /></p>

<h3 id="validation이-중요한-이유">Validation이 중요한 이유</h3>
<ol>
  <li><strong>데이터 무결성 보장</strong>
    <ul>
      <li>검증되지 않은 데이터가 서버로 들어오면 데이터베이스의 일관성이 깨질 수 있습니다.</li>
      <li>예를 들어, 생년월일 필드에 알파벳이 포함되거나 전화번호에 특수 문자가 포함되는 경우, 데이터의 신뢰성을 확보하기 어렵습니다. 이때 Validation을 통해 이러한 잘못된 데이터를 사전에 차단할 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>보안 강화</strong>
    <ul>
      <li>유효하지 않은 데이터는 SQL 인젝션, 스크립트 인젝션(XSS) 등과 같은 보안 취약점을 노출시킬 수 있습니다.</li>
      <li>Validation을 통해 이러한 악성 입력을 막음으로써 백엔드 시스템을 보호할 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>애플리케이션 안정성 유지</strong>
    <ul>
      <li>Validation을 통해 예상하지 못한 데이터 형식으로 인한 에러를 줄일 수 있습니다.</li>
      <li>검증된 데이터만을 처리하기 때문에 애플리케이션의 안정성과 성능을 유지할 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>비즈니스 로직 보호</strong>
    <ul>
      <li>유효성 검사는 단순히 데이터 형식을 확인하는 것뿐만 아니라, 비즈니스 로직에 맞는 데이터인지 검토할 수 있습니다.
<br />
<br /></li>
    </ul>
  </li>
</ol>

<h3 id="사용-방법">사용 방법</h3>
<h4 id="1-의존성-추가"><strong>1. 의존성 추가</strong></h4>
<p>Spring Boot를 사용한다면 아래처럼 javax.validation 또는 jakarta.validation 패키지를 기본적으로 제공하지만, 프로젝트에 따라 Hibernate Validator 의존성을 명시적으로 추가해야 할 수도 있습니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">validation</span><span class="err">'</span>
</code></pre></div></div>

<h4 id="2-어노테이션-추가"><strong>2. 어노테이션 추가</strong></h4>
<p>Validation은 주로 어노테이션을 기반으로 동작하기 때문에 DTO에 검증 어노테이션을 추가하여 Spring이 자동으로 검증을 수행하게 할 수 있습니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserRequest</span> <span class="o">{</span>

	<span class="nd">@NotBlank</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"이름을 필수입니다."</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="nd">@Email</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"이메일 형식을 확인해주세요."</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>
	<span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">8</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"비밀번호는 최소 8자 이상이어야 합니다."</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>

	<span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-컨트롤러에서-적용"><strong>3. 컨트롤러에서 적용</strong></h4>
<p>컨트롤러에서 @Valid 어노테이션을 사용하여 DTO를 검증할 수 있습니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>

    <span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"/users"</span><span class="o">)</span>
	<span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">saveUser</span><span class="o">(</span><span class="nd">@Valid</span> <span class="nd">@RequestBody</span> <span class="nc">UserRequest</span> <span class="n">userRequest</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="s">"successfully saved User!"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="4-검증-에러-처리"><strong>4. 검증 에러 처리</strong></h4>
<p>검증에 실패하면 Spring Boot는 기본적으로 MethodArgumentNotValidException을 발생시킵니다. 이를 처리하기 위해 @ExceptionHandler를 사용하거나 @ControllerAdvice를 통해 글로벌하게 처리할 수 있습니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestControllerAdvice</span>
<span class="kd">class</span> <span class="nc">CommonExceptionHandler</span> <span class="o">{</span>

    <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">CommonResponse</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;&gt;</span> <span class="nf">handleValidationException</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">ResponseEntity</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">CommonResponse</span><span class="o">&lt;&gt;(</span><span class="nc">ErrorCode</span><span class="o">.</span><span class="na">INVALID_REQUEST_FORMAT</span><span class="o">.</span><span class="na">getErrorMessage</span><span class="o">(),</span> <span class="kc">null</span><span class="o">),</span> <span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="많이-쓰는-애노테이션과-팁">많이 쓰는 애노테이션과 팁</h3>
<h4 id="기본-애노테이션">[기본 애노테이션]</h4>
<p><code class="language-plaintext highlighter-rouge">@NotNull</code>, <code class="language-plaintext highlighter-rouge">@NotEmpty</code>, <code class="language-plaintext highlighter-rouge">@NotBlank</code></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@NotNull</code>은 null이 아닌 값으로, 모든 타입에 사용 가능</li>
  <li><code class="language-plaintext highlighter-rouge">@NotEmpty</code>은 null이거나 비어있지 않은 값으로, CharSequence, Collection, Map, 배열만 사용 가능</li>
  <li><code class="language-plaintext highlighter-rouge">@NotBlank</code>는 null, 빈 문자열(<code class="language-plaintext highlighter-rouge">””</code>), 하나 이상의 공백이 아닌 문자만 허용</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">@Size</code></p>
<ul>
  <li>문자열, 배열, 컬렉션의 길이나 크기를 제한</li>
  <li>min, max 속성을 사용해 범위를 설정할 수 있음
<br /></li>
</ul>

<h4 id="숫자-관련-애노테이션">[숫자 관련 애노테이션]</h4>
<p><code class="language-plaintext highlighter-rouge">@Min</code></p>
<ul>
  <li>숫자 필드의 최소값 지정</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">@Max</code></p>
<ul>
  <li>숫자 필드의 최댓값 지정</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">@Positive</code>, <code class="language-plaintext highlighter-rouge">@PositiveOrZero</code></p>
<ul>
  <li>값이 양수인지(0 포함 여부 선택)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">@Negative</code>, <code class="language-plaintext highlighter-rouge">@NegativeOrZero</code></p>
<ul>
  <li>값이 음수인지(0 포함 여부 선택)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">@Digits</code></p>
<ul>
  <li>정수와 소수의 자리수를 지정할 수 있음</li>
  <li><code class="language-plaintext highlighter-rouge">@Digits(integer = 3, fraction = 2, message = “정수 3자리, 소수 2자리까지 가능합니다.”)</code>
<br /></li>
</ul>

<h4 id="문자열-관련-애노테이션">[문자열 관련 애노테이션]</h4>
<p><code class="language-plaintext highlighter-rouge">@Email</code></p>
<ul>
  <li>문자열이 이메일 형식인지 검증</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">@Pattern</code></p>
<ul>
  <li>정규표현식을 사용하여 값이 특정한 패턴을 만족하는지 검증</li>
  <li><code class="language-plaintext highlighter-rouge">@Pattern(regexp = "^[0-9]{10}$", message = "전화번호는 10자리 숫자여야 합니다.")</code>
<br /></li>
</ul>

<h4 id="날짜-관련-애노테이션">[날짜 관련 애노테이션]</h4>
<p><code class="language-plaintext highlighter-rouge">@Past, @PastOrPresent</code></p>
<ul>
  <li>값이 과거 날짜인지, 현재 날짜를 포함한 과거인지 검증</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">@Future</code>, <code class="language-plaintext highlighter-rouge">@FutureOrPresent</code></p>
<ul>
  <li>값이 미래 날짜인지, 현재 날짜를 포함한 미래인지 검증
<br />
<br /></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Spring" /><category term="SpringBoot" /><category term="Validation" /><category term="글또" /><category term="글또10기" /><summary type="html"><![CDATA[배경 백엔드 작업에서 Validation은 꽤나 중요도가 높은 작업으로, 클라이언트가 보내는 데이터가 서버에서 기대하는 형식과 규칙을 충족하는지 확인하는 과정을 의미합니다. 주로 웹 애플리케이션에서 클라이언트가 API를 통해 데이터를 전송할 때 백엔드에서는 이 데이터가 정확한지, 요구사항을 만족하는지 검증을 해야 데이터베이스에 저장하거나 다음 처리를 진행하게 됩니다.]]></summary></entry><entry><title type="html">이직 후기, 그리고 글또 다짐을 곁들인</title><link href="http://localhost:4000/blog/2024/10/13/geultto-first-post.html" rel="alternate" type="text/html" title="이직 후기, 그리고 글또 다짐을 곁들인" /><published>2024-10-13T00:00:00+09:00</published><updated>2024-10-13T00:00:00+09:00</updated><id>http://localhost:4000/blog/2024/10/13/geultto-first-post</id><content type="html" xml:base="http://localhost:4000/blog/2024/10/13/geultto-first-post.html"><![CDATA[<h4 id="이직">이직</h4>
<p>7월에 SI 스타트업으로 이직했습니다. 공모전 발표 다음날이라 순위의 영향은 크지 않았겠지만, 작업한 내용이 Github에 올라가 있으니 코드 내용으로 봐주셨겠죠. 조금 더 면접을 보고 결정하고 싶었지만, 포트폴리오가 괜찮은 편이라 긍정적으로 결정했습니다.</p>

<p>1월 퇴사 이후 전회사가 상식 밖으로 힘든 곳이었지만 오히려 개발자라는 직업이 내가 하고 싶은 일이라는 걸 확실하게 깨달았습니다.. 그래서 실무 경험을 보여주고자 비사이드 포텐데이에도 참가하고, 운좋게 거기에서 만난 팀원들과 함께 공모전에 참여해서 2등이라는 좋은 결과도 얻을 수 있었네요. 상반기가 매우 바쁘기도 했지만, 그만큼 보람이 있었습니다. 😊
<br />
<br /></p>

<h4 id="요즘-일하면서-느낀-건">요즘 일하면서 느낀 건</h4>
<p>7월 입사인데 벌써 2번째 프로젝트를 한창 진행하고 있는데요. 거의 혼자 백단을 개발하게 되었지만, 저번 프로젝트보다 더 나은 코드를 작성하고 싶어서 애쓰는 중입니다. 글또에 참여한 이유 중 하나지만 SI 특성상 짧은 시간 안에 개발해야 하다보니 기록해두지 않으면 남는 게 없을 것 같더라구요. 그래서 잊어버리지 않도록 틈틈이 트러블 슈팅도 기록해두고, 업무일지도 점점 세분화해서 작성하고 있습니다.
<br />
<br /></p>

<h4 id="글또에-가입한-이유">글또에 가입한 이유</h4>
<p>저는 주변 환경에 굉장히 영향을 많이 받는 편입니다. 안타깝게도 전/현회사 모두 기술 블로그를 운영하거나 글에 관심이 있는 분위기가 아니다보니, 그런 사람들이 모여있는 곳을 원했습니다. 그러다가 올해 초에 알게 된 글또 10기 신청 알림 메일이 왔을 때 너무 기뻤습니다. 지원서가 생각보다 빡세서 떨어지면 어떡하지 걱정했었지만, “삶의 지도”라는 주제에 대해 작성했을 때도 제 인생에 대해 많이 생각해보게 되어 정말 좋았습니다. 여러모로 지쳐가던 때에 원동력으로 삼을 수 있는 사람들이 있는 곳에 참여하게 되었으니, 저도 다시 긍정적으로 생산성있는 일상을 만들어 보고 싶습니다. 😊
<br />
<br /></p>

<h4 id="글감-정리">글감 정리</h4>
<p>자유로운담소에 올라온 채정님의 글감정리를 보고 저도 작성해봤습니다. (채정님 감사합니다!)
<img width="745" alt="글감정리" src="https://github.com/user-attachments/assets/cf7bbb74-2552-47c9-9a08-af322108c23c" />
전반적으로 관심있으면서 제대로 한 번 깊게 파보고 싶은 부분들을 모아봤는데요, 변경 가능성이 있지만 2주씩 꾸준히 시간을 투자해서 저도 정리하고 보는 분들도 흥미있게 읽을 수 있도록 작성해보겠습니다 👍 
<br />
그리고 별개로 미뤄두었던 블로그 정비를 다시 해야겠다고 생각했습니다. 이번주 안에 반드시 댓글과 방명록 기능을 추가해 볼게요 😉
<br />
<br /></p>

<h4 id="다짐">다짐</h4>

<p>블로그를 작성하면서 공부하거나 작업하면서 알게 된 내용을 정리했지만, 다시 읽어보면 가독성도 떨어지고 뭔가 다른 사람들의 블로그를 베끼는 것 같더라구요. 그래서 저는 글또를 통해 좋은 글을 많이 보고 주제에 대해 충분히 고민해보고 작성해보려고 합니다. 또 글을 쓰는 재미와 방법에 대해 많이 알아가고 싶어요. 첫 글부터 마감일에 작성하게 되어서 괜시리 머쓱하지만 바로 다음주 글부터는 미리미리 써보도록 하겠습니다 ‼️</p>

<p>글또가 본격적으로 시작한지 벌써 2주가 되었네요. 그동안 소모임에도 간간히 참여하고(주로 달려또🏃), 이번주에는 같은 백엔드인 다혜님을 튜사에서 만나 작업 겸 저녁챗을 진행했는데 감사하게도 이런저런 얘기를 해주셔서 덕분에 좋은 시간을 보냈습니다. ㅎㅎ 남은 10월에도 튜사에 한 번 정도는 더 방문해보고 싶네요. 지원서에 적었던 것처럼 열정적인 글또분들에게 원동력을 얻어서 더 열심히 참여하고 글도 써봐야겠습니다.</p>]]></content><author><name>Dajeong Park</name></author><category term="blog" /><category term="회고" /><category term="글또" /><category term="글또10기" /><summary type="html"><![CDATA[이직 7월에 SI 스타트업으로 이직했습니다. 공모전 발표 다음날이라 순위의 영향은 크지 않았겠지만, 작업한 내용이 Github에 올라가 있으니 코드 내용으로 봐주셨겠죠. 조금 더 면접을 보고 결정하고 싶었지만, 포트폴리오가 괜찮은 편이라 긍정적으로 결정했습니다.]]></summary></entry><entry><title type="html">AccessToken과 RefreshToken</title><link href="http://localhost:4000/wiki/2024/07/13/accesstoken-refreshtoken.html" rel="alternate" type="text/html" title="AccessToken과 RefreshToken" /><published>2024-07-13T00:00:00+09:00</published><updated>2024-07-13T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/07/13/accesstoken-refreshtoken</id><content type="html" xml:base="http://localhost:4000/wiki/2024/07/13/accesstoken-refreshtoken.html"><![CDATA[<h3 id="accesstoken과-refreshtoken">AccessToken과 RefreshToken</h3>
<p><code class="language-plaintext highlighter-rouge">AccessToken</code>은 사용자에 대한 정보를 담아 서비스에 접근(Access)할 수 있는 토큰이다.</p>

<p><code class="language-plaintext highlighter-rouge">RefreshToken</code>은 <code class="language-plaintext highlighter-rouge">AccessToken</code>과 다른 특별한 기능은 없지만, <code class="language-plaintext highlighter-rouge">AccessToken</code>을 새로 발급해주는 용도로 사용한다.
<br />
<br /></p>

<h4 id="accesstoken의-문제">AccessToken의 문제</h4>
<p><code class="language-plaintext highlighter-rouge">AccessToken</code>만 사용하는 기존의 인증 방식은 토큰이 탈취되었을 때 문제가 발생한다.</p>

<p>또 이러한 상황에서도 내부에서는 해당 토큰이 탈취되었는지 구분할 수 없다. 그래서 유효기간이 필요한 것이다.</p>

<p>그렇다고 유효기간이 너무 짧아도 사용자가 자주 로그인해야 하는 번거로움이 생기고, 유효기간을 늘리는 것 또한 보안에 취약할 수밖에 없다.
그래서 유효기간이 다른 <code class="language-plaintext highlighter-rouge">AccessToken</code>과 <code class="language-plaintext highlighter-rouge">RefreshToken</code> 2개를 사용하는 것이다.
<br />
<br /></p>

<h4 id="refreshtoken-사용">RefreshToken 사용</h4>
<p><code class="language-plaintext highlighter-rouge">RefreshToken</code>은 <code class="language-plaintext highlighter-rouge">AccessToken</code>처럼 JWT를 사용하지만, AccessToken는 내부 데이터에 접근하고, <code class="language-plaintext highlighter-rouge">RefreshToken</code>은 <code class="language-plaintext highlighter-rouge">AccessToken</code>을 재발급하는 역할을 한다.</p>

<p>회원가입이나 로그인에 성공할 때 2가지 토큰을 모두 발급해준다. 
데이터베이스에는 <code class="language-plaintext highlighter-rouge">RefreshToken</code>을 저장하고, 클라이언트에는 <code class="language-plaintext highlighter-rouge">AccessToken</code>과 <code class="language-plaintext highlighter-rouge">RefreshToken</code>을 보내 쿠키/세션/스토리지에 저장하여 토큰이 필요한 API마다 헤더(보통 Authorization)에 담아서 보낸다.</p>

<p><code class="language-plaintext highlighter-rouge">RefreshToken</code>은 <code class="language-plaintext highlighter-rouge">AccessToken</code>보다 유효기간이 길기 때문에, AccessToken이 만료되면 데이터베이스에 저장한 <code class="language-plaintext highlighter-rouge">RefreshToken</code>을 확인하여 다시 <code class="language-plaintext highlighter-rouge">AccessToken</code>을 재발급 해준다.
<br />
<br /></p>

<h4 id="발급-프로세스">발급 프로세스</h4>
<ol>
  <li>서버는 회원가입/로그인 성공 시 <code class="language-plaintext highlighter-rouge">AccessToken</code>과 <code class="language-plaintext highlighter-rouge">RefreshToken</code>를 발급하여 클라이언트에 전달한다.
    <ul>
      <li>이때 <code class="language-plaintext highlighter-rouge">RefreshToken</code>은 데이터베이스에 저장해둔다.</li>
    </ul>
  </li>
  <li>클라이언트는 전달받은 <code class="language-plaintext highlighter-rouge">AccessToken</code>과 <code class="language-plaintext highlighter-rouge">RefreshToken</code>을 로컬(쿠키/세션/스토리지 등)에 저장한다.</li>
  <li>클라이언트는 토큰이 필요한 API의 헤더(Authorization)에 <code class="language-plaintext highlighter-rouge">AccessToken</code>을 넣어 요청을 보낸다.
    <ul>
      <li>서버에서는 인증된 사용자인지 먼저 검증한 후 요청 API의 로직을 수행하여 응답을 보낸다.</li>
    </ul>
  </li>
  <li>로그아웃 API 요청 시 서버에서는 데이터베이스에 저장해둔 <code class="language-plaintext highlighter-rouge">RefreshToken</code>을 삭제한다.
<br />
<br /></li>
</ol>

<h4 id="토큰-검증-분기">토큰 검증 분기</h4>

<table>
  <thead>
    <tr>
      <th>AccessToken</th>
      <th>RefreshToken</th>
      <th>결과</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>유효</td>
      <td>유효</td>
      <td>정상 상태로 이후 로직 수행</td>
    </tr>
    <tr>
      <td>만료</td>
      <td>유효</td>
      <td>클라이언트의 RefreshToken과 데이터베이스의 RefreshToken을 비교하여 AccessToken 재발급</td>
    </tr>
    <tr>
      <td>유효</td>
      <td>만료</td>
      <td>AccessToken을 검증하여 RefreshToken 재발급</td>
    </tr>
    <tr>
      <td>만료</td>
      <td>만료</td>
      <td>재로그인을 요청하여 토큰을 새로 발급받도록 유도</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h4 id="참고">참고</h4>
<ul>
  <li><a href="[https://inpa.tistory.com/entry/WEB-📚-Access-Token-Refresh-Token-원리-feat-JWT](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-Access-Token-Refresh-Token-%EC%9B%90%EB%A6%AC-feat-JWT)">Access Token &amp; Refresh Token 원리</a></li>
  <li><a href="[https://velog.io/@chuu1019/Access-Token과-Refresh-Token이란-무엇이고-왜-필요할까](https://velog.io/@chuu1019/Access-Token%EA%B3%BC-Refresh-Token%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C)">Access Token과 Refresh Token이란 무엇이고 왜 필요할까?</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="JWT" /><category term="AccessToken" /><category term="RefreshToken Network" /><summary type="html"><![CDATA[AccessToken과 RefreshToken AccessToken은 사용자에 대한 정보를 담아 서비스에 접근(Access)할 수 있는 토큰이다.]]></summary></entry><entry><title type="html">JWT(JSON Web Token)</title><link href="http://localhost:4000/wiki/2024/07/01/jwt.html" rel="alternate" type="text/html" title="JWT(JSON Web Token)" /><published>2024-07-01T00:00:00+09:00</published><updated>2024-07-01T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/07/01/jwt</id><content type="html" xml:base="http://localhost:4000/wiki/2024/07/01/jwt.html"><![CDATA[<h3 id="jwtjson-web-token-">JWT(JSON Web Token) ?</h3>
<ul>
  <li><strong>JWT(Json Web Token)</strong>란 인증에 필요한 JSON 데이터를 암호화시켜 저장한 Web Token
<br /></li>
</ul>

<h4 id="왜-jwt를-사용할까">왜 JWT를 사용할까?</h4>
<ul>
  <li>HTTP는 <strong>무상태(Stateless)</strong>와 <strong>비연결성(Connectionless)</strong>이라는 특성을 가지고 있다.
    <ol>
      <li><strong>Stateless</strong>: 이전 상태를 유지/기억하지 않음
        <ul>
          <li>장점: 서버의 확장성이 높음</li>
          <li>단점: 클라이언트에게 추가 데이터를 전송해야 함</li>
        </ul>
      </li>
      <li><strong>Connectionless</strong>: 연결을 유지하지 않음</li>
    </ol>
  </li>
  <li>연결을 유지하지 않고(Connectionless) 이전 상태도 기억하지 못한다(Stateless)는 것은 이동하는 페이지마다 요청을 새로 해야한다는 것을 의미한다. 즉, 사용자가 신뢰성이 있는 사용자인지 매번 인증해야 한다.</li>
  <li>이는 번거로울 뿐만 아니라 통신이 느려질 수도 있기 때문에 한 번 인증된 사용자가 일정 기간 인증을 유지하도록 JWT를 사용한다.
<br />
<br /></li>
</ul>

<h4 id="jwt의-구조">JWT의 구조</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xxxxxx</span><span class="o">.</span><span class="na">yyyyyy</span><span class="o">.</span><span class="na">zzzzzz</span> <span class="c1">// Header.Payload.Signature</span>
</code></pre></div></div>
<ul>
  <li>JWT는 <code class="language-plaintext highlighter-rouge">.</code>을 구분자로 나누어 구성된 3가지 문자열이다.</li>
  <li>Header, Payload는 Base64 URL-safe로 인코딩되어 누구나 쉽게 복호화할 수 있기 때문에 절대 중요한 정보를 넣으면 안 되지만, Signature는 비밀키가 없으면 복호화할 수 없기 때문에 보안상 안전하다.</li>
</ul>

<p><strong>Header</strong></p>
<ul>
  <li>Signature를 해싱하기 위한 해시 알고리즘 정보, 토큰 타입</li>
</ul>

<p><strong>Payload</strong></p>
<ul>
  <li>서버와 클라이언트가 주고 받으며, 시스템에서 실제로 사용될 정보에 대한 내용들
    <ul>
      <li>대상, 이름, 발급일시, 만료일시 등</li>
    </ul>
  </li>
</ul>

<p><strong>Signature</strong></p>
<ul>
  <li>Header + Payload + 비밀키(서명)를 Header의 알고리즘으로 암호화한 문자열
    <ul>
      <li>토큰의 위변조 여부를 확인하기 위해 사용됨</li>
      <li>Header나 Payload의 데이터를 위조해도, Signature를 통해 유효한 토큰인지 알 수 있음
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="장점">장점</h4>
<ul>
  <li>로컬에 저장하기 때문에 서버 용량에 영향을 주거나 받지 않는다.</li>
  <li>비밀키를 통해 서명하기 때문에 보다 안전하다.</li>
  <li>HTTP 헤더나 URL 파라미터로 간단하게 전송하기 때문에 네트워크 부하가 적다.
<br /></li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>Payload에 저장되는 정보가 많아지면 네트워크 사용량이 증가하여, 데이터 설계 고려가 필요해진다.</li>
  <li>토큰이 클라이언트에 저장되어, 서버에서 클라이언트의 토큰을 조작할 수 없다.</li>
  <li>토큰이 발급되면 중간에 만료 기간 변경이 불가능하므로, 토큰 만료 처리를 구현해야 한다.
<br />
<br /></li>
</ul>

<h4 id="정리">정리</h4>
<p>JWT도 토큰 탈취의 보안 위험에서 벗어날 수 없기 때문에, 실무에서는 AccessToken과 RefreshToken처럼 기한이 있는 인증 방식을 사용한다.</p>

<p>둘 다 JWT로 구현되지만, AccessToken은 기한이 짧고(몇 시간에서 며칠) 클라이언트에 저장된다.
RefreshToken은 AccessToken보다 수명이 길어(2주 이상) AccessToken의 재발급을 위해 사용하며 최근에는 보안을 위해 데이터베이스에 저장하고 있다.</p>

<p>그리고 AccessToken는 만료 기한이 짧기 때문에 로그인을 자주 해야하는 번거로움이 있을 수 있으니 AccessToken만 사용하기보다는 RefreshToken을 함께 사용해서 편리하고 보안을 강화하는 게 좋아보인다.
<br />
<br /></p>

<h4 id="프로젝트에-적용한-방법">프로젝트에 적용한 방법</h4>
<ul>
  <li>가입 시 내부에서 사용할 정보를 키값과 함께 인코딩하여 accessToken과 refreshToken을 생성하는데, accessToken은 헤더에 담아 리턴해주고, refreshToken은 DB에 저장한다.</li>
  <li>클라이언트로부터 API 요청을 받을 때 accessToken이 필요하다면 함께 받은 뒤 확인하는데, 이때 만약  accessToken이 만료되었다면 DB의 refreshToken을 조회해서 만료되지 않았으면 accessToken을 새로 발급해준다.
    <ul>
      <li>하지만 이때 refreshToken도 만료되었다면 다시 로그인하도록 에러를 리턴한다.</li>
    </ul>
  </li>
</ul>

<p>❓refreshToken은 어디에 두어야 할까? accessToken만 주는 것이 아니라 refreshToken도 같이 줘야 하나? 그래서 accessToken이 만료되거나 없으면 다시 같이 발급해주고 ?</p>
<ul>
  <li>accessToken만 사용하다가 보안 문제로 인해 refreshToken도 같이 발급하기 시작</li>
  <li>refreshToken을 로컬에 저장해둘 수도 있지만, refreshToken처럼 탈취할 수 있다는 단점이 있어 최근에는 refreshToken을 서버에 저장하기 시작함</li>
  <li>결국 지금 사용하는 방식이 괜찮은 방식이며, AccessToken과 RefreshToken의 개념과 HTTP에 대해서 더 자세히 알아보는게 좋겠다.
<br />
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li><a href="https://velog.io/@chuu1019/%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-JWTJson-Web-Token">알고 쓰자, JWT(Json Web Token)</a></li>
  <li><a href="https://inpa.tistory.com/559">JWT 토큰 인증 이란? (쿠키 vs 세션 vs 토큰)</a></li>
  <li><a href="https://puleugo.tistory.com/138">우리는 왜 JWT를 사용하는가? / JWT 사용 이유</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="JWT" /><category term="Network" /><summary type="html"><![CDATA[JWT(JSON Web Token) ? JWT(Json Web Token)란 인증에 필요한 JSON 데이터를 암호화시켜 저장한 Web Token]]></summary></entry><entry><title type="html">Mixed Content The page at ‘…’ was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint ‘…’. This request has been blocked; the content must be served over HTTPS 에러를 Nginx에서 해결하기</title><link href="http://localhost:4000/wiki/2024/06/21/csp.html" rel="alternate" type="text/html" title="Mixed Content The page at ‘…’ was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint ‘…’. This request has been blocked; the content must be served over HTTPS 에러를 Nginx에서 해결하기" /><published>2024-06-21T00:00:00+09:00</published><updated>2024-06-21T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/06/21/csp</id><content type="html" xml:base="http://localhost:4000/wiki/2024/06/21/csp.html"><![CDATA[<h4 id="배경">배경</h4>
<p><img width="758" alt="스크린샷 2024-06-20 16 16 48" src="https://github.com/dabeann/dorandoran/assets/61612976/7066d92c-1dbc-4b89-8b71-5813cfd575d7" />
지난 프로젝트에서도 CORS 문제가 발생해서 하루만에 도메인도 구매하고 Nginx로 연결한 다음 Spring Boot 프로젝트에서 CORS 설정도 해줬었는데, 이번 프로젝트에서도 동일한 방법을 실행했지만 CORS가 해결되지 않는 문제가 발생했다. <del>(이 문제로 서버도 몇 번이나 다시 만들고 nginx 파일을 몇 십번이나 했었다..)</del><br />
<br />
<br /></p>

<h4 id="원인-및-결과">원인 및 결과</h4>
<p>Nginx에서 proxy_pass를 127.0.0.1(localhost)로 연결해줬다. 이 부분이 https로 연결된 도메인과 함께 사용돼서 Mixed Content 에러가 발생한 것이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server <span class="o">{</span>
    listen 443 ssl<span class="p">;</span> <span class="c"># managed by Certbot</span>

    ...

    location / <span class="o">{</span>
        proxy_pass http://127.0.0.1:8008<span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>구글이나 GPT에 아무리 검색을 해봐도 이렇게 사용하는 게 맞는데 대체 뭐가 문제인지 찾아보다가 정말 많은 시간을 보냈다. 
<br /></p>

<p>그러다가 CORS 해결 방법 중에 meta 태그를 추가하는 방법에서 생각해봤다. 이 태그를 Nginx에 적용할 수 없을까?
검색해보니 <code class="language-plaintext highlighter-rouge">add_header Content-Security-Policy "upgrade-insecure-requests";</code>를 추가하면 된대서 적용해보니 바로 해결되었다.<br />
결국 서버 내에서 HTTP 보안 정책 중 하나인 CPS를 위반해서 발생한 문제였다..</p>

<h4 id="완성한-코드">완성한 코드</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server <span class="o">{</span>
    listen 443 ssl<span class="p">;</span> <span class="c"># managed by Certbot</span>

    ...

    location / <span class="o">{</span>
        proxy_pass http://127.0.0.1:8008<span class="p">;</span>
        add_header Content-Security-Policy <span class="s2">"upgrade-insecure-requests"</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="content-security-policycsp">Content-Security-Policy(CSP)?</h4>
<ul>
  <li>위에서 추가해준 <strong>Content-Security-Policy(CSP)</strong>는 콘텐츠 보안 정책으로, 웹 애플리케이션이 웹 페이지에서 로드할 수 있는 리소스의 종류를 제어하는 보안 기능이다. CSP는 보통 XSS나 Injection 공격을 방지하는 데 사용한다.</li>
  <li>Content-Security-Policy에 추가해준 <strong>upgrade-insecure-request</strong>는 HTTP로 요청된 리소스를 자동으로 HTTPS로 업그레이드하도록 브라우저에 지시한다. 즉, HTTPS를 지원하는 모든 리소스를 보안 연결을 통해 업로드할 수 있게 되어 데이터를 보호할 수 있는 것이다.
<br />
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li><a href="https://blog.harampark.com/blog/mixed-content-error">Mixed Content The page at ‘xxx’ was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint ‘yyy’. This request has been blocked; the content must be served over HTTPS 에러 해결하기</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="CPS" /><category term="Server" /><category term="Error" /><category term="TroubleShooting" /><summary type="html"><![CDATA[배경 지난 프로젝트에서도 CORS 문제가 발생해서 하루만에 도메인도 구매하고 Nginx로 연결한 다음 Spring Boot 프로젝트에서 CORS 설정도 해줬었는데, 이번 프로젝트에서도 동일한 방법을 실행했지만 CORS가 해결되지 않는 문제가 발생했다. (이 문제로 서버도 몇 번이나 다시 만들고 nginx 파일을 몇 십번이나 했었다..)]]></summary></entry><entry><title type="html">비사이드 403 포텐데이 Americanote 회고</title><link href="http://localhost:4000/blog/2024/05/16/americanote-review.html" rel="alternate" type="text/html" title="비사이드 403 포텐데이 Americanote 회고" /><published>2024-05-16T00:00:00+09:00</published><updated>2024-05-16T00:00:00+09:00</updated><id>http://localhost:4000/blog/2024/05/16/americanote-review</id><content type="html" xml:base="http://localhost:4000/blog/2024/05/16/americanote-review.html"><![CDATA[<h2 id="americanote-️">Americanote ☕️</h2>
<blockquote>
  <p><em>프로젝트:</em> 아메리카노트 (내 취향에 딱 맞는 아메리카노 카페 찾기 서비스)<br />
<em>프로젝트 기간:</em> 2024.03.21 ~ 2024.03.30, 리팩토링 2024.04</p>
</blockquote>

<p><img src="https://github.com/dajeongdev/Americanote/assets/61612976/6956afbf-def5-4fc8-af36-4e9689304868" alt="중간산출물_Americanote" /></p>

<p><br />
<br /></p>

<h3 id="기술-스택">기술 스택</h3>
<p><strong>Backend</strong></p>
<ul>
  <li>Java 17, Spring Boot, Spring Data JPA, QueryDSL</li>
  <li>Spring Security, JWT
<br /></li>
</ul>

<p><strong>DevOps</strong></p>
<ul>
  <li>NaverCloudPlatform Ubuntu Server, MySQL, Global Domain</li>
  <li>Nginx, LetsEncrypt
<br />
<br /></li>
</ul>

<h3 id="서비스-아키텍처">서비스 아키텍처</h3>
<p><img width="918" alt="service-architecture" src="https://github.com/dajeongdev/Americanote/assets/61612976/26eccda0-7573-4a6f-8736-049b69d9bc41" />
<br />
<br /></p>

<h2 id="kptkeep-problem-try">KPT(Keep, Problem, Try)</h2>

<h3 id="keep">Keep</h3>

<p><strong>팀빌딩 시 적극적으로 행동하기</strong></p>

<p>비사이드 포텐데이에 관한 소개나 후기를 찾아보니 첫날부터 4일간 팀빌딩을 직접 할 수 있다고 해서 자기소개를 미리 적어두고, 팀빌딩이 시작되고 자기소개를 제일 먼저 올렸다. 평소엔 생각이 많아서 무언가를 제일 먼저 하는 편이 아닌데, 이번 프로젝트를 굉장히 잘하고 싶은 마음이 커서 조금 더 적극적으로 행동했다. 그 결과 몇 분께 DM을 받았고, 그중에 현재 팀의 백엔드분이 이미 팀이 구성되어 있다고 한 부분이 매력적으로 느껴져셔 합류하게 되었다.
<br /></p>

<p><strong>Swagger 사용</strong></p>

<p>인턴 때 팀원들에게서 배웠던 Swagger 설정을 이번에는 직접 해볼 수 있었다. 생각보다 어렵지 않고 설정만 해주면 그룹별로 나눠서 볼 수도 있고, 프론트분께 API를 효율적으로 전달할 수 있었다. 조금 아쉬운 점을 찾자면 프론트 분이 swagger를 사용해 본 적이 없으셔서 잘 활용했는지 의문인데, 이 부분은 설명서 같은 걸 만들어 드렸면 더 좋았을 것 같다.</p>

<p><img width="828" alt="swagger" src="https://github.com/dajeongdev/Americanote/assets/61612976/294d5327-45b3-4c2c-99c6-cb34e0e56551" />
<br /></p>

<p><strong>Git Flow로 협업하기</strong></p>

<p>Git Flow도 인턴 때 배웠었는데, 이번에는 Jira도 사용하지 않았기 때문에 포텐데이에서 제공해준 방법으로 간단하게 develop에서 feature를 따서 PR 후 코드 리뷰를 한 다음 merge 하는 방식으로 진행했다.</p>

<p>서로 코드를 보면서 나은 방법을 고민하기도 하고, 왜 이 코드를 썼는지 설명해주기도 해서 정말 유익한 시간이었다. 실무와 인턴 때 배웠던 부분에 대해 백엔드 팀원에게 공유해주다보니 내가 부족한 부분, 더 알아야 할 부분도 함께 알게 돼서 오히려 좋은 기회였다는 생각이 든다.</p>

<p><img width="824" alt="gitflow" src="https://github.com/dajeongdev/Americanote/assets/61612976/0e49712f-b6ac-4fb8-b088-782106914f68" />
<br /></p>

<p><strong>JWT 구현</strong></p>

<p>예전 팀플이나 실무에서도 JWT를 종종 사용했지만 내가 직접 구현하는 건 처음이었는데, 생각보다 복잡해서 여러 프로젝트를 참고해서 만들었다.
<br /></p>

<p><strong>Naver Cloud로 Cloud Server 작업</strong></p>

<p>이번 프로젝트 때 서버를 거의 담당하게 되었다. 실무 때나 개인 프로젝트 때는 AWS만 다뤄봤는데, 이번에는 비사이드 측과 연계된 Naver Cloud Platform을 사용해봤다. 처음에 클라우드 서버가 Naver Cloud Platform이라고 했을 때는 사용해보지 않은 플랫폼이라 걱정이 조금 됐었는데, 막상 사용해보니까 별로 다를 것도 없고 사이트에도 설명을 잘 적어놔서 생각보다 수월하게 서버, DB, 네임서버까지 사용할 수 있었다. (<del>비용 관련해서는 AWS가 확실히 더 저렴한 것 같긴 하다..</del>)
<br /></p>

<p><strong>바로 리팩토링하기</strong></p>

<p>프로젝트 종료 다음날 백엔드 팀원과 바로 디코로 만나 리팩토링할 부분을 정리했다. 그 결과 아쉬워했던 부분을 4월 안에 거의 해결할 수 있었고, 4월 초에 쿼리최적화나 CI/CD 부분을 리팩토링해서 조금 더 나은 코드로 발전시킬 수 있어서 정말 좋은 경험이 되었다.
<br />
<br /></p>

<h3 id="problem">Problem</h3>
<ol>
  <li>
    <p><strong>HTTPS 없이 API 구현</strong><br />
개인적으로 가장 아쉬우면서 경험이 쌓였던 부분이다. 개발 초기에 도메인을 구매하려고 생각은 했으나 비용도 있고 굳이 사야하나 해서 public ip로 API를 제공했었는데, 마감 전날 프론트 쪽에서 백으로 요청을 보낼 때 백의 도메인이 HTTPS가 아니라 요청이 아예 막혀서 문제가 됐었다.. 이 부분 덕분에 그날 새벽 4시까지 서버와 싸우느라 시간 낭비한 부분이 너무 아쉬웠다.
<br /></p>
  </li>
  <li>
    <p><strong>Validation과 Error 처리</strong><br />
10일 동안 기능 구현하기 급급하다보니 가장 중요한 데이터 validation이나 error 처리가 부족했다.
<br /></p>
  </li>
  <li>
    <p><strong>수동 배포</strong><br />
이 부분 또한 가장 해보고 싶었던 부분인데 결국 자동 배포에 실패하고 개발 당시에는 수동으로 배포했었다..
<br /></p>
  </li>
  <li>
    <p><strong>accessToken을 오히려 불편하게 사용함</strong><br />
실무에서 JWT의 accessToken에서 바로 userId를 뽑아서 사용한 적이 있는데, 역시 직접한 부분이 아니다보니 이번에도 10일 안에 적용하기 힘들었다. 그래서 시간 내에 accessToken을 제대로 사용하지 못한 부분이 정말 아쉬웠다.
<br /></p>
  </li>
  <li>
    <p><strong>N+1 문제</strong><br />
내가 작성한 부분은 아니었지만 같이 작업한 백엔드분이 작성한 코드에서 N+1 문제가 발생했다. JPA 메소드쿼리로 여러 객체를 불러오다보면 생기는 문제였는데, 빠른 시간 안에 해결하기 힘들어하셔서 결국 리팩토링 때 하기로 하고 프로젝트를 마무리하게 되었다.
<br />
<br /></p>
  </li>
</ol>

<h3 id="try">Try</h3>
<ol>
  <li><strong>HTTPS 적용</strong><br />
마감 전날 부랴부랴 도메인을 구매하고, 서버에서 Letsencrypt를 시도해봤지만 네임서버 에러로 바로 SSL이 발급되지 않았다. 찾아보니 새벽 4시까지 에러와 싸우다가 결국 다음날 오후에 사용이 가능해서 발급받을 수 있었다..
    <ul>
      <li><a href="https://dajeongdev.github.io/wiki/2024/04/29/americanote-server6-apply-https-to-the-domain.html">자세한 과정 보러가기</a>
<br /></li>
    </ul>
  </li>
  <li>
    <p><strong>Validation과 Error 처리</strong>  <br />
입력값에 대한 validation이나 에러 처리는 대부분 토큰에 관련된 부분이었다. 그래서 모두 처리해주고 나니 accessToken 부분 필터로 처리하면 될 것 같다는 생각이 들어서 그 부분은 다음번에 진행해주었다.
<br /></p>
  </li>
  <li><strong>배포 자동화</strong>  <br />
다양한 방법을 찾아보던 중 Github Actions self-hosted runner를 사용한 배포 자동화를 해보기로 했다.  해당 리포지토리에서 Github Actions Runner를 생성하고, 서버에서 명령어를 입력해서 설치한 후 Github Actions의 workflow를 생성해서 처리했다.
    <ul>
      <li><a href="https://dajeongdev.github.io/wiki/2024/04/29/americanote-server4-automatical-deploy.html">자세한 과정 보러가기</a>
 <br /></li>
    </ul>
  </li>
  <li>
    <p><strong>필터에서 accessToken 처리하기</strong><br />
이전 코드는 컨트롤러에서 HttpServletRequest를 파라미터로 받아 header에 있는 Authorization을 뽑아 사용하는 방식이었다. 그러다보니 토큰이 필요한 모든 컨트롤러에서 파라미터로 HttpServletRequest를 받아야 해서 코드가 불필요하게 길어졌는데, 이 부분을 필터에서 처리해서 코드를 정말 많이 줄일 수 있었다.
에러 처리 또한 토큰이 있고 없고에 따른 분기 처리가 필요한 곳이 몇몇 있어서 그에 따른 2가지 에러로 분류하니 훨씬 일관성 있고 깔끔한 코드로 처리할 수 있게 되었다.
<br /></p>
  </li>
  <li>
    <p><strong>QueryDSL로 N+1 문제 해결</strong><br />
카페와 커피 객체를 한번에 가져오다보니 20개의 카페 목록을 가져올 때 쿼리가 100개가 나오는 문제가 있었다. 
아무래도 취향에 따라 카페를 추천해주는 코드는 조금 복잡할 수 밖에 없어서 최대한 줄이는 방향으로 진행했고, 메소드쿼리로 작성했던 부분을 조금 더 구체적인 객체로 가져올 수 있도록 수정하거나 QueryDSL로 처리해서 쿼리 갯수를 많이 줄일 수 있었다. 
QueryDSL에 관련해서는 나도 많이 부족했지만, 실무에서의 경험으로 팀원분께 조금이나마 도움을 줄 수 있어서 다행이라고 생각했다.
<br /></p>
  </li>
  <li><strong>And so on 👍</strong>
    <ul>
      <li>Naver Cloud 측에서 제공해주는 서버 비용이 남아서 이번 달 안에 꼭 Docker로 CI/CD를 시도해보려고 한다.</li>
      <li>JWT도 다 이해된 건 아니라 더 자세히 공부해보고 이번달 안에 반드시 블로그 포스팅까지 해볼 것이다.</li>
      <li>현재 아메리카노트 팀원들과 공모전을 진행하고 있는데, 열심히 작업해서 좋은 경험이 되었으면 한다.
<br />
<br /></li>
    </ul>
  </li>
</ol>

<h2 id="소감">소감</h2>
<p>포텐데이에 참여한 이유는 1년 정도 실무에서 배운 부분을 코드로 보여주기 위해서였다. 개발에 대한 경험도 정말 좋았지만 팀원들과의 협업과 10일이라는 시간동안 하루에 10시간씩 집중하는 내 모습을 통해서 내가 ‘백엔드 개발자’라는 직무에 정말 재미를 느끼고 있다는 걸 알게 되었다.</p>

<p>그리고 정말 운이 좋게 스펀지 같은 흡수력과 포용력을 가진 팀원을 만나서 내가 조금이나마 알고 있는 지식을 공유하고, 또 설명해주기 전에 지식에 대한 타당한 이유를 찾기 위해 노력하는 시간들이 정말 도움이 많이 됐다.</p>

<p>입사하면 신입이나 주니어는 보통 세팅된 환경에서만 개발을 하기 때문에 나 또한 전회사에서 기초 설정에 대한 부분을 사수나 다른 팀원들이 해줬었는데, 이번 프로젝트로 Swagger 설정이나 서버, JWT 같은 기본이라고 하면 할 수 있는 중요한 부분을 작업하면서 개발자로서 조금 더 나아가는 느낌을 받았다.</p>

<p>또한, 기획이나 프론트 팀원과도 의사소통하면서 내가 알고 있는 지식을 상대방의 설명하는 게 정말 힘들었기 때문에, 앞으로 의미가 잘 전달될 수 있도록 말을 조금 더 잘 고르고 상대의 입장을 생각해 봐야겠다.</p>]]></content><author><name>Dajeong Park</name></author><category term="blog" /><category term="TeamProject" /><category term="Project" /><category term="Americanote" /><category term="Review" /><summary type="html"><![CDATA[Americanote ☕️ 프로젝트: 아메리카노트 (내 취향에 딱 맞는 아메리카노 카페 찾기 서비스) 프로젝트 기간: 2024.03.21 ~ 2024.03.30, 리팩토링 2024.04]]></summary></entry><entry><title type="html">독서 관리 서비스의 Admin 개발 회고</title><link href="http://localhost:4000/blog/2024/05/10/book-service-admin-review.html" rel="alternate" type="text/html" title="독서 관리 서비스의 Admin 개발 회고" /><published>2024-05-10T00:00:00+09:00</published><updated>2024-05-10T00:00:00+09:00</updated><id>http://localhost:4000/blog/2024/05/10/book-service-admin-review</id><content type="html" xml:base="http://localhost:4000/blog/2024/05/10/book-service-admin-review.html"><![CDATA[<p>홈페이지 마이그레이션, 도서 단행본 API 구현 업무를 마치고 나니 협력사와 아이가 도서를 읽고 독후감을 쓰면 첨삭해주는 서비스를 만들게 됐는데, 당시 일손이 부족해서 내가 관리자를 통으로 담당하게 되었다.
<br />
<br /></p>

<p>사수분들께서 바빠서 잘 봐줄 수 없을 것 같다고 하셔서 (ㅎㅎ) 기획서를 받기 전부터 조금 긴장했던 것 같다.
기초 설정은 차장님께서 해주셔서 Spring Boot 2.4.1 버전에 Maven을 사용한 프로젝트를 생성해주셨고, 홈페이지 마이그레이션 때처럼 Thymeleaf를 사용하기로 했는데, 마이그레이션 때 사용해봐서 걱정은 조금 덜었었다.
<br />
<br /></p>

<p>관리자 페이지답게 엑셀 다운로드부터 Push(FCM) 발송, 첨삭 수동 매칭, 첨삭 교사의 라이센스 확인, 관리자 권한 설정 그리고 사용자 통계까지 정말 다양한 기능을 8월 중순부터 1월 초까지 작업했으니 약 5개월동안 정말 열심히 했었다. 그래서 힘들다기보다는 해보지 못했던 기능을 만들어봐서 정말 재미있게 개발했다.
<br />
<br /></p>

<p>이번 프로젝트에서는 기획서가 있었는데, 미리 주신 덕분에 보면서 “내가 관리자라면 검색할 때 이 조건을 불편하지 않을까?”라고 관리자의 입장에서 생각해보면서 추가하거나 삭제해도 괜찮을 것 같은 기능들을 정리해서 운영팀 과장님과 상의하면서 작업했더니 확실히 완성도가 올라간다는 느낌이 들었다. 이때부터 기획서나 피그마를 잘 분석해서 의사소통하는 게 팀워크에 좋은 영향을 끼친다고 생각했다.
<br />
<br /></p>

<h4 id="프론트단">프론트단</h4>
<p>관리자 페이지의 프론트 부분을 제대로 작업해본 건 처음이었는데, 디자인에 너무 신경쓰지 않아도 된다고 하셨지만 그래도 어느정도는 깔끔하게 보이고 싶었다.</p>

<p>아무래도 관리자 페이지는 비슷한 페이지들이 많다보니 모달이나 글자수 카운팅, 페이징, 이미지 탭 같은 부분을 공통적으로 사용하는 게 좋을 것 같다고 판단해서 그런 기능들은 컴포넌트화 시켜서 사용하기 시작했다.</p>

<p>그리고 개발 트렌드에 맞게 jQuery 대신 Javascript만 사용하고 싶다는 목표도 세웠기 때문에 작업 중에 드림코딩이나 노마드코더 같은 Javascript 강의를 들어보니 Java랑 조금 다른 부분들이 재미있게 느껴졌다.
<br />
<br /></p>

<h4 id="백단">백단</h4>
<p>백단 작업도 이전 프로젝트보다 더 발전하고 싶다는 생각이 들었다. 김영한님의 Spring 강의를 들으면서 @Autowired 대신 생성자 주입을 위해 @RequiredArgument 사용하는 것처럼 더 나은 코드를 위해 필요한 부분들을 체크해서 실무에 적용해보기도 했다.</p>

<p>백단 부분은 계속 MyBatis를 사용했기 때문에 입사 전에 했던 팀프로젝트 때랑 많이 다르지 않아서 편했지만, 통계나 여러 테이블을 조인하는 과정이 어려웠기 때문에 대리님께 질문도 드리고, 개인적으로도 검색을 통해 많이 배웠다. 최근에는 JPA만 써서 MyBatis도 한 번 제대로 정리해봐야겠다..</p>

<p>그리고 이때 처음으로 프로젝트를 서버에 배포하는 것도 알려주셔서 해봤는데 생각보다 어려워서 공부를 많이 해야겠다고 생각했다. 실서버가 2개라는 것도 차장님이 말씀을 안 해주셔서 막바지에 알게 된 해프닝도 있었다. ㅋㅋ
<br />
<br /></p>

<h4 id="소감">소감</h4>
<p>중간중간 운영팀 과장님과 대리님께 피드백도 받아가면서 프로젝트를 마무리했더니 의사소통도 잘하고 손이 빠르다는 평을 들었다. 새로운 기능도 많이 개발해보고, 프론트단도 처음이지만 이리저리 공부하면서 작업한 부분도 정말 뿌듯했다. 이 프로젝트를 통해서 팀원들과의 의사소통과 사용자 입장에서 개발하는 것의 중요성을 뼈저리게 깨달았다.</p>

<p>그리고 공부해서 바로 실무에 적용해보는 게 정말 재미있기도 했는데, 실제로 다음 프로젝트부터는 VO를 보호하기 위해 DTO와 Builder 패턴을 사용하는 등 김영한님의 강의가 정말 하나하나 피가 되고 살이 되어서 모든 강의를 다 수강해서 열심히 공부하기도 했다.</p>]]></content><author><name>Dajeong Park</name></author><category term="blog" /><category term="Project" /><category term="Admin" /><category term="Review" /><summary type="html"><![CDATA[홈페이지 마이그레이션, 도서 단행본 API 구현 업무를 마치고 나니 협력사와 아이가 도서를 읽고 독후감을 쓰면 첨삭해주는 서비스를 만들게 됐는데, 당시 일손이 부족해서 내가 관리자를 통으로 담당하게 되었다.]]></summary></entry><entry><title type="html">도서 등록 API 속도 개선 회고</title><link href="http://localhost:4000/blog/2024/05/10/book-insert-api-speed-improvement-review.html" rel="alternate" type="text/html" title="도서 등록 API 속도 개선 회고" /><published>2024-05-10T00:00:00+09:00</published><updated>2024-05-10T00:00:00+09:00</updated><id>http://localhost:4000/blog/2024/05/10/book-insert-api-speed-improvement-review</id><content type="html" xml:base="http://localhost:4000/blog/2024/05/10/book-insert-api-speed-improvement-review.html"><![CDATA[<p>홈페이지 마이그레이션 이후 새로운 업무를 받았다.</p>

<p>당시 자사 서비스인 도서 플랫폼에서는 사용자로부터 도서 등록 문의를 받아 등록해줬었다.</p>

<p>문의한 도서가 ‘전집’일 때는 운영팀에서 도서를 검색해서 개발팀에게 전달해 데이터베이스에 등록하는 과정을 거쳤지만,<br />
‘단행본’일 때는 운영팀에서 관리자 페이지에서 직접 등록하기도 했다.<br />
하지만 점점 요청이 많아지기도 해서 내가 ‘단행본’ 등록하는 API를 개발하게 되었다.
<br />
<br /></p>

<p>기존 전집 등록 API를 이용하면 금방 만들 수 있겠다고 생각했지만, 도서 플랫폼의 백단 프로젝트가 거대한 레거시 프로젝트라는 한 가지 복병이 있었다.</p>

<p>레거시 프로젝트는 JPA로 구성되어 있었지만, JPA의 장점을 하나도 사용하지 않는 데다 특정 메소드만 사용하고 있었고,<br />
사용하고 있는 특정 메소드 또한 방대한 중복 및 로깅 코드에 클래스와 메소드 이름이 중구난방에 의미도 불분명했다.<br />
게다가 데이터베이스도 테이블이 엄청나게 얽혀 있어 함부로 수정할 수 없는 상태였다.
<br />
<br /></p>

<p>이런 상태에서 그대로 단행본 API만 만들 수도 있었지만, 왠지 마음이 찝찝해서 기존 전집 등록 API부터 개선해보기로 했다. 그리고 이때 속도를 비교해보면 좋을 것 같아서 <code class="language-plaintext highlighter-rouge">System.currentTimeMillis</code> 메소드를 사용해서 이전 코드의 속도를 측정해보니 50권의 전집을 등록할 때 5.56초가 걸렸다.
<br />
<br /></p>

<p>일단 이리갔다 저리갔다 코드가 너무 보기 불편했기 때문에 클래스와 메서드부터 연관성에 따라서 재배치하거나 분리했다.<br />
그리고 불명확하게 작성되어 있던 메소드 이름도 가독성 있는 이름으로 바꿨다.<br />
마지막으로는 수많은 로깅 및 주석 코드를 정리했고, 중간중간 중복 코드도 찾아내어 삭제했다.</p>

<p>이후 코드 속도를 다시 측정해보니 같은 전집을 등록할 때 3.27초로 속도가 개선되었다.
<br />
<br /></p>

<p>이후 단행본 API를 구현하는 건 정말 간단했다.<br />
원래는 같은 API를 쓰고 싶었지만, 운영팀에서 주시는 전집과 단행본의 엑셀 컬럼이 달라서 다른 API로 분리를 한 다음<br />
엑셀을 읽어들이는 부분만 다르게 설정하고, 내부 로직은 동일한 메소드를 사용하도록 조정했다.
<br />
<br /></p>

<h4 id="소감">소감</h4>
<p>단행본 API를 구현하라는 업무에서 사실상 전집 API를 개선하는 데 더 시간을 많이 보냈지만 개인적으로 정말 뿌듯한 업무였다. ㅎㅎ 주니어 때 해보기 힘든 속도도 개선도 해보고, 데이터에 영향이 가지 않도록 고민하는 과정들이 개발자라는 직업에 대해 깊이 있게 생각하게 만들어 준 것 같다~!</p>]]></content><author><name>Dajeong Park</name></author><category term="blog" /><category term="Project" /><category term="Review" /><summary type="html"><![CDATA[홈페이지 마이그레이션 이후 새로운 업무를 받았다.]]></summary></entry><entry><title type="html">홈페이지 마이그레이션 회고</title><link href="http://localhost:4000/blog/2024/05/09/hompage-migration-review.html" rel="alternate" type="text/html" title="홈페이지 마이그레이션 회고" /><published>2024-05-09T00:00:00+09:00</published><updated>2024-05-09T00:00:00+09:00</updated><id>http://localhost:4000/blog/2024/05/09/hompage-migration-review</id><content type="html" xml:base="http://localhost:4000/blog/2024/05/09/hompage-migration-review.html"><![CDATA[<p>포트폴리오를 작성하다보니 생각보다 예전에 했던 프로젝트들이 회고해볼 만한 게 많아서 한 번 되짚어보려고 한다.
<br />
<br /></p>

<p>입사 당시 첫 주는 거의 일이 없어서 심심했었는데, 2주차에는 드디어 첫 업무를 받았다.
<br /></p>

<p>Spring 4.3.3, Maven, JSP로 구성되어 있던 프로젝트를 Spring Boot, Gradle, Thymeleaf로 마이그레이션 하는 업무였는데, 마이그레이션 자체도 처음이고 Spring Boot와 Thymeleaf도 처음 써보는 거라 걱정반 기대반으로 조사부터 했었다.
<br /></p>

<p>다행스럽게도 마이그레이션에 대한 레퍼런스가 많아서 찬찬히 읽어보고 시작했다.
<br /></p>

<p>일단 Spring 4점대가 이미 개발 지원이 종료된 상태였고, 불필요한 중복 코드나 주석도 많아서 함께 리팩토링하기로 했다. 그리고 한꺼번에 바꾸게 되면 에러날 확률이 높다고 해서 하나씩 바꾸기로 했다.
<br />
<br /></p>

<h4 id="1-spring--springboot">1. Spring → SpringBoot</h4>
<p>spring boot 의존성도 추가하고, xml 파일들을 yml 혹은 config 파일로 분리했다.</p>

<p>xml 파일이 적지 않아서 yml 문법에 맞게 옮기는 데 시간이 조금 걸렸고, java config 파일은 웬만하면 만들고 싶지 않아서 yml 문법으로 가능한 건 다 yml로 처리했었다.
<br /></p>

<h4 id="2-maven--gradle">2. Maven → Gradle</h4>
<p>maven에서 gradle로 변경하는 건 생각보다 간단했는데, 일단 gradle을 설치하고 환경변수를 설정한 후 프로젝트 내에서 reload gradle project를 해주면 된다.</p>

<p>그런데 빌드하면서 에러가 발생했는데 lombok 부분을 annotationProcessor로 변경해주니 금방 해결되었다.
<br /></p>

<h4 id="3-jsp--thymeleaf">3. JSP → Thymeleaf</h4>
<p>당연하지만 3가지 순서 중에 가장 오래 걸린 부분이다.
<br /></p>

<p>사실 이 부분은 내가 하고 싶어서 한 부분인데, JSP를 지양하는 문화로 가기도 했고 Spring Boot를 사용할 때 Thyemelaf를 권고한다고 해서 써보고 싶었다. Thymeleaf는 성능면에서 JSP보다 조금 느리지만, Jar 파일로 빌드할 수 있다. 그리고 무엇보다 HTML과 자바 코드가 섞이지 않아도 되는 점이 가장 마음에 들었다.
<br /></p>

<p>Thymeleaf는 JSP와 인식되는 폴더 자체가 다르기 때문에 폴더 구조부터 수정한 뒤 jsp 파일을 html 파일로 변경했다.</p>

<p>이후부터는 Thymeleaf 문법에 맞추는 수작업이었는데, Thymeleaf 설정에서 cache를 false로 설정해주면 브라우저에서 새로고침만으로도 바로 변경사항을 반영해볼 수 있어서 정말 편리했다.
<br />
<br /></p>

<h4 id="ps-css하">P.S. CSS..하..</h4>
<p>진짜 여러모로 CSS 덕분에 아주 눈물이 날 뻔 했다. Thymeleaf까지만 해도 재미있었는데, 확신의 백엔드인건지 CSS 부분 수정하는 데 더 오래 걸려서 아주 미치는 줄 알았다.
이미지인 줄 알았는데 하드 코딩된 거라는 것도… ㅋㅋㅋㅋ 그래도 실무에서 이런 경험 해보는 것도 나쁘지 않았다.. 이후 관리자 개발할 때도 많이 도움되기도 했고!
<br />
<br /></p>

<h4 id="소감">소감</h4>
<p>사실 지금 생각해보면 아주 간단한 프로젝트였고, 모르는 게 있으면 질문을 정리해서 대리님께 물어봤기 때문에 금방 해낼 수 있었다.
첫 업무를 생각보다 빠르게 끝내서 기분 좋기도 했고(당연하지만 지금 하면 더 잘할 수 있을텐데),
회사에서도 뭔가 시켜도 되겠다 싶으셨는지 이후에 업무를 차근차근 받아서 진행하는 계기가 됐었다.
<br /></p>

<p>지금 생각해보면 일하느라 바빠서 말도 많이 안했던 것 같은데 ㅋㅋ 조용히 열심히 하는 직원으로 생각해주셨으려나~</p>]]></content><author><name>Dajeong Park</name></author><category term="blog" /><category term="Java" /><category term="Spring" /><category term="SpringBoot" /><category term="Maven" /><category term="Gradle" /><category term="JSP" /><category term="Thymeleaf Migration" /><category term="Review" /><summary type="html"><![CDATA[포트폴리오를 작성하다보니 생각보다 예전에 했던 프로젝트들이 회고해볼 만한 게 많아서 한 번 되짚어보려고 한다.]]></summary></entry></feed>