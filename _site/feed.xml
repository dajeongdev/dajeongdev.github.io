<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2024-04-29T22:23:22+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Every Single Day</title><subtitle></subtitle><author><name>Dajeong Park</name></author><entry><title type="html">아메리카노트 서버 구성 &amp;lt;5&amp;gt; 도메인 연결</title><link href="http://localhost:4000/wiki/2024/04/29/americanote-server5-connect-domain-name.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;5&amp;gt; 도메인 연결" /><published>2024-04-29T00:00:00+09:00</published><updated>2024-04-29T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/29/americanote-server5-connect-domain-name</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/29/americanote-server5-connect-domain-name.html"><![CDATA[<ul>
  <li>자동 배포까지 했으니 어느정도는 백엔드 코드를 서버에 올리는 것까지 했다고 할 수 있겠습니다.</li>
  <li>저도 여기가 마지막인 줄 알았으나..
<img src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/9ba32892-8688-4f23-aa75-806a8df95b37" alt="domain1" /></li>
  <li>첨부한 이미지는 프론트분이 API가 요청되지 않는다고 캡쳐해주신 에러 메세지입니다. 읽어보면 HTTPS인 프론트 도메인에서 HTTP인 백엔드 도메인으로 요청하는 부분에서 XMLHttpRequest 에러가 발생했습니다. 바로 CORS 문제입니다 ㅎㅎ</li>
  <li>검색해보니 프론트 쪽에서 간단하게 <code class="language-plaintext highlighter-rouge">&lt;meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"&gt;</code> 같은 HTML 코드를 넣어서 해결하는 방법도 있었지만, 그래도 저희는 해결되지 않아서 결국 도메인을 구매하기로 결정했습니다. (심지어 마감 전날 토요일에 ㅎㅎ)
<br />
<br /></li>
</ul>

<h4 id="1-카페24에서-도메인-구매">1. 카페24에서 도메인 구매</h4>
<ul>
  <li>아주 익숙한 카페24에서 도메인을 구매하기로 결정했습니다.</li>
  <li>좋은 이름이면 참 좋겠지만 프론트에서 API로 요청할 때만 필요하기 때문에 1년에 단돈 500원에 구매할 수 있는 <code class="language-plaintext highlighter-rouge">.store</code>를 선택했습니다.</li>
</ul>

<p><img width="875" alt="domain2" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/b015dcca-441f-4fe1-9067-0577379b6bc6" />
<br />
<br /></p>

<h3 id="2-서버에-nginx-설치하기">2. 서버에 Nginx 설치하기</h3>
<ul>
  <li>이제 도메인과 서버를 연결해주기 위해서 서버에 nginx를 설치해보겠습니다.</li>
  <li>먼저 설치하기 전에 패키지 목록을 업데이트 해줍니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt upgrade
</code></pre></div>    </div>
  </li>
  <li>그리고 nginx를 설치하겠습니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>nginx
</code></pre></div>    </div>
  </li>
  <li>계속할지 묻는 메시지가 표시되면 ‘Y’를 누르고 enter 키를 치다보면 설치가 완료됩니다.
  <img width="970" alt="domain3" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/4943ca29-1701-4786-9015-11ec1efd5ed1" />
    <ul>
      <li>저는 이렇게 하다가 중간에 에러가 발생했는데요, 이유는 IPV6 설정때문이었습니다. 해결해주기 위해 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/default</code> 파일에 접근해서 아래처럼 수정해줍니다.
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  server <span class="o">{</span>
      listen 80 default_server<span class="p">;</span>
      <span class="c"># listen [::]:80 default_server; # 이 부분 주석 처리</span>
    
      ...
    
      root /var/www/html<span class="p">;</span>
    
      <span class="c"># Add index.php to the list if you are using PHP</span>
      index index.html index.htm index.nginx-debian.html<span class="p">;</span>
    
      server_name _<span class="p">;</span>
    
      location / <span class="o">{</span>
              <span class="c"># First attempt to serve request as file, then</span>
              <span class="c"># as directory, then fall back to displaying a 404.</span>
              try_files <span class="nv">$uri</span> <span class="nv">$uri</span>/ <span class="o">=</span>404<span class="p">;</span>
      <span class="o">}</span>
  				...
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>이제 설치를 마쳤으면 nginx를 시작합니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>service nginx start
<span class="nb">sudo </span>service nginx status <span class="c"># nginx 상태 확인</span>
</code></pre></div>    </div>
    <p><img width="1045" alt="domain4" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/5447c65d-2df6-4850-945c-e19f8dd219b6" />
<br />
<br /></p>
  </li>
</ul>

<h4 id="3-방화벽-설정">3. 방화벽 설정</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>ufw app list
</code></pre></div></div>
<ul>
  <li>위의 명령어를 입력하여 방화벽 설정을 확인하면 방화벽 설정이 가능한 애플리케이션 목록이 나옵니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Available applications:
Nginx Full <span class="c"># 80, 443 포트 허용</span>
Nginx HTTP <span class="c"># 80 포트만 허용</span>
Nginx HTTPS <span class="c"># 443 포트만 허용</span>
OpenSSH
</code></pre></div>    </div>
  </li>
  <li>저희는 이 다음에 HTTPS까지 적용하기 위해서 ‘Nginx Full’ 방화벽을 허용해줍니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>ufw allow <span class="s1">'Nginx Full'</span>
<span class="nb">sudo </span>ufw status <span class="c"># 상태 체크</span>
</code></pre></div>    </div>
    <p>```bash
Status: inactive</p>
  </li>
</ul>

<p>To                         Action      From
–                         ——      —-
Nginx HTTP                 ALLOW       Anywhere
Nginx HTTP (v6)            ALLOW       Anywhere (v6)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 그리고 위처럼 상태가 inactive로 되어있으면 아래 명령어를 입력하여 활성화 시켜줍니다.
    - ***tip***: 아래 명령어를 입력하면 ssh 연결을 방해할 수도 있다는 경고 문구가 나오는데, 이때 y를 하기 전에 반드시 22번 포트를 허용하거나 제한해줍니다.
    &lt;img width="608" alt="domain5" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/429317de-249e-49fb-b516-7ebe01647d45"&gt;
    ```bash
    sudo ufw limit/allow 22
    ```
    - 처음 설정할 때는 이 부분을 몰라서 ssh에 들어갈 수 없게 되는 사태가 벌어졌지만, NCP 서버 콘솔에 원격으로 접속하는 곳으로 들어가 22번 포트를 허용하는 방식으로 겨우 해결했습니다…💦💦💦
```bash
sudo ufw enable
</code></pre></div></div>
<ul>
  <li>이제 public ip로 접근해보면 nginx 화면이 성공적으로 뜨는 것을 확인할 수 있습니다.</li>
</ul>

<p><img width="745" alt="domain6" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/d9ee761f-1926-4fce-82dd-85382f1eb292" />
<br />
<br /></p>

<h4 id="4-도메인-연결">4. 도메인 연결</h4>
<ul>
  <li>public ip로 뜨는 걸 봤으니 이제 도메인과 연결해주겠습니다.</li>
  <li>먼저 기본 nginx의 화면이 아닌 다른 화면으로 출력하기 위해 index.html 파일을 만들어줍니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /var/www/도메인이름/html <span class="c"># 폴더 생성</span>
<span class="nb">sudo chown</span> <span class="nt">-R</span> <span class="nv">$USER</span>:<span class="nv">$USER</span> /var/www/도메인이름/html <span class="c"># 소유자 설정</span>
<span class="nb">sudo chmod</span> <span class="nt">-R</span> 755 /var/www/도메인이름 <span class="c">#권한 설정</span>
<span class="nb">sudo </span>vi /var/www/도메인이름/html/index.html <span class="c"># index.html 파일 생성</span>
</code></pre></div>    </div>
  </li>
  <li>위에서 수정했던 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/default</code> 파일 대신 이번에는 도메인 이름으로 된 파일을 만들어서 아래처럼 설정해줍니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vi /etc/nginx/sites-available/도메인이름
<span class="c"># 위 파일로 자동으로 이동한 뒤 아래 내용 입력</span>
server <span class="o">{</span>
  listen 80<span class="p">;</span>

  root /var/www/도메인 이름/html<span class="p">;</span> <span class="c"># 위에서 만든 html 폴더</span>
  index index.html index.htm index.nginx-debian.html<span class="p">;</span>

  server_name 도메인 이름 www.도메인 이름<span class="p">;</span>

  location / <span class="o">{</span>
      try_files <span class="nv">$uri</span> <span class="nv">$uri</span>/ <span class="o">=</span>404<span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>위 파일을 nginx에서 연결해주기 위해 해당 파일을 sites-enabled 폴더에 심볼릭 링크 설정을 해줍니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/도메인이름 /etc/nginx/sites-enabled/
</code></pre></div>    </div>
  </li>
  <li>이제 브라우저에서 도메인을 입력하면 위에서 생성한 index.html이 확인할 수 있습니다.
<br />
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li>https://jaehyeon48.github.io/nginx/configure-nginx-on-ubuntu-2004/</li>
  <li><a href="https://velog.io/@xangj0ng/Linux-Ubuntu-Nginx-%EC%84%A4%EC%B9%98">https://velog.io/@xangj0ng/Linux-Ubuntu-Nginx-설치</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Server" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="DNS" /><summary type="html"><![CDATA[자동 배포까지 했으니 어느정도는 백엔드 코드를 서버에 올리는 것까지 했다고 할 수 있겠습니다. 저도 여기가 마지막인 줄 알았으나.. 첨부한 이미지는 프론트분이 API가 요청되지 않는다고 캡쳐해주신 에러 메세지입니다. 읽어보면 HTTPS인 프론트 도메인에서 HTTP인 백엔드 도메인으로 요청하는 부분에서 XMLHttpRequest 에러가 발생했습니다. 바로 CORS 문제입니다 ㅎㅎ 검색해보니 프론트 쪽에서 간단하게 &lt;meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"&gt; 같은 HTML 코드를 넣어서 해결하는 방법도 있었지만, 그래도 저희는 해결되지 않아서 결국 도메인을 구매하기로 결정했습니다. (심지어 마감 전날 토요일에 ㅎㅎ)]]></summary></entry><entry><title type="html">아메리카노트 서버 구성 &amp;lt;2&amp;gt; MySQL 데이터베이스 생성</title><link href="http://localhost:4000/wiki/2024/04/29/americanote-server2-create-mysql-database.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;2&amp;gt; MySQL 데이터베이스 생성" /><published>2024-04-29T00:00:00+09:00</published><updated>2024-04-29T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/29/americanote-server2-create-mysql-database</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/29/americanote-server2-create-mysql-database.html"><![CDATA[<p>이번에는 NCP에서 MySQL DB Server를 생성하고 연결해보겠습니다.
<br />
<br /></p>

<h4 id="db-server-생성">DB Server 생성</h4>
<p><img width="678" alt="create-mysql1" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/44d6bbc1-bc7a-46b8-ba8f-11681852aac9" /></p>
<ul>
  <li>고가용성까지는 필요 없기 때문에 해제를 해주고, 이전 단계에서 만들었던 VPC와 Subnet을 선택해주었습니다.
<br />
<br />
<br /></li>
</ul>

<p><img width="551" alt="create-mysql2" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/a51e2e02-7af7-4614-a433-f81839ad3545" /></p>
<ul>
  <li>기본 설정에서 거의 건드리지 않고 DB server와 서비스 이름만 지정해주었습니다.
<br />
<br />
<br /></li>
</ul>

<p><img width="682" alt="create-mysql3" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/c4d4c493-9ce9-45e5-94b3-54ee3004eec0" /></p>
<ul>
  <li>USER_ID와 USER 암호로 MySQL admin을 생성해줍니다.</li>
  <li>HOST는 접속할 Client IP를 입력하는 건데 아래 예시처럼 전체 접속을 허용해주기 위해 %를 입력했습니다.
<br />
<br />
<br /></li>
</ul>

<p><img width="362" alt="create-mysql4" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/95182b3c-e4e8-4d00-8ed5-7061fd7667dd" /></p>
<ul>
  <li>또한 백업 설정은 추가 요금이 발생한다길래 과감히 포기했습니다^^..</li>
  <li>다음을 누르고 최종 확인을 하면 몇 분 안에 DB 서버가 생성됩니다.
<br />
<br />
<br /></li>
</ul>

<h4 id="방화벽acg-설정">방화벽(ACG) 설정</h4>
<ul>
  <li>생성 후 끝이 아니라 DB에 접속하기 위해 방화벽을 설정해줍니다.</li>
  <li>참고로 DB에 0.0.0.0으로 모두 허용해주는 게 위험하다고 생각해서 자주 쓰는 IP들만 등록해두었습니다.</li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="MySQL" /><category term="DataBase" /><summary type="html"><![CDATA[이번에는 NCP에서 MySQL DB Server를 생성하고 연결해보겠습니다.]]></summary></entry><entry><title type="html">아메리카노트 서버 구성 &amp;lt;3&amp;gt; 프로젝트 배포</title><link href="http://localhost:4000/wiki/2024/04/29/americanote-server3-deploy-project.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;3&amp;gt; 프로젝트 배포" /><published>2024-04-29T00:00:00+09:00</published><updated>2024-04-29T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/29/americanote-server3-deploy-project</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/29/americanote-server3-deploy-project.html"><![CDATA[<p>서버와 데이터베이스를 생성했다면 이번에는 서버에 프로젝트를 배포해보겠습니다.
<br />
<br /></p>

<h4 id="1-서버에-접근하기">1. 서버에 접근하기</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh username@public-ip <span class="nt">-p</span> 22<span class="o">(</span>허용 포트<span class="o">)</span>
<span class="c"># password</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="2-서버에-java-설치">2. 서버에 JAVA 설치</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>openjdk-17-jdk
java <span class="nt">--version</span> <span class="c"># 자바 버전 확인</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="3-프로젝트-가져오기">3. 프로젝트 가져오기</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone <span class="nt">--branch</span> 가져올브랜치 https://github.com/깃헙아이디/레포지토리명.git <span class="c"># 프로젝트 복제</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="4-별도로-필요한-yml-파일이-있다면-optional">4. 별도로 필요한 yml 파일이 있다면 (optional)</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>Americanote <span class="c"># 리포지토리로 들어가기</span>
<span class="nb">cd </span>src/main/resources <span class="c"># yml 파일이 위치할 resources 폴더로 이동</span>
<span class="nb">cat</span> <span class="o">&gt;</span> ~.yml <span class="c"># yml 파일 생성 및 편집</span>
<span class="c"># yml 파일 내용 붙여넣기</span>
<span class="c"># 필요한 yml 파일을 모두 만들었으면 다시 리포지토리 홈으로 돌아갑니다.</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="5-gradle-빌드-후-실행하기">5. Gradle 빌드 후 실행하기</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./gradlew clean build <span class="nt">-x</span> <span class="nb">test</span> <span class="c"># 테스트 없이 처음부터 빌드</span>
<span class="nb">cd </span>build/libs <span class="c"># jar 파일이 존재하는 폴더로 이동</span>
ll 혹은 <span class="nb">ls</span> <span class="c"># 폴더 보기</span>
<span class="nb">nohup </span>java <span class="nt">-jar</span> <span class="o">[</span>이름-SNAPSHOT.jar] &amp;
</code></pre></div></div>
<ul>
  <li>nohup
    <ul>
      <li>no hang up의 약자, 말그대로 끊지마!</li>
      <li>사용자가 세션과 연결을 종료해도, 데몬 형태로 실행하게 하여 해당 프로세스가 종료되지 않습니다.</li>
    </ul>
  </li>
  <li>&amp;
    <ul>
      <li>프로그램 실행 시 마지막에 붙여주면 백그라운드에서 해당 프로세스가 실행됩니다.
<br />
  → 어떤 프로그램을 종료없이 백그라운드에서 실행시킬 때 <code class="language-plaintext highlighter-rouge">nohup ~ &amp;</code> 조합을 사용하는 게 가장 확실하고 안전합니다.
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="6-로그-확인">6. 로그 확인</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 실행 후 ll 이나 ls로 확인해보면 nohup.out이 생성됩니다.</span>
<span class="nb">tail</span> <span class="nt">-f</span> nohup.out <span class="c"># 실시간 업데이트 로그</span>
<span class="nb">cat </span>nohup.out     <span class="c"># 현재까지 로그</span>
</code></pre></div></div>
<ul>
  <li>제대로 실행되었는지 확인하기 위해 로그를 실행 후 로그를 반드시 확인하는 편입니다.
<br />
<br /></li>
</ul>

<h4 id="7-만약-이미-프로젝트가-실행-중이라면-종료하고-실행하자">7. 만약 이미 프로젝트가 실행 중이라면? 종료하고 실행하자</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netstat <span class="nt">-tulpn</span> <span class="c"># 실행 중인 프로세스 확인</span>
<span class="nb">kill</span> <span class="nt">-9</span> <span class="o">[</span>PID 번호]
</code></pre></div></div>
<ul>
  <li>Gradle 빌드 후 실행하기 전에 한번쯤 확인하면 좋겠습니다.
<br />
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li><a href="https://1.theapplemango.com/entry/%EB%84%A4%EC%9D%B4%EB%B2%84-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%ED%94%8C%EB%9E%AB%ED%8F%BCNCP-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%B6%95-%EB%B0%8F-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B0%B0%ED%8F%AC%EA%B9%8C%EC%A7%80-2">https://1.theapplemango.com/entry/네이버-클라우드-플랫폼NCP-서버-구축-및-스프링-배포까지-2</a></li>
  <li><a href="https://joonyon.tistory.com/entry/%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%9C-nohup-%EA%B3%BC-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%82%AC%EC%9A%A9%EB%B2%95">https://joonyon.tistory.com/entry/쉽게-설명한-nohup-과-백그라운드-명령어-사용법</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Server" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="Deploy" /><summary type="html"><![CDATA[서버와 데이터베이스를 생성했다면 이번에는 서버에 프로젝트를 배포해보겠습니다.]]></summary></entry><entry><title type="html">아메리카노트 서버 구성 &amp;lt;4&amp;gt; 자동 배포</title><link href="http://localhost:4000/wiki/2024/04/29/americanote-server4-automatical-deploy.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;4&amp;gt; 자동 배포" /><published>2024-04-29T00:00:00+09:00</published><updated>2024-04-29T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/29/americanote-server4-automatical-deploy</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/29/americanote-server4-automatical-deploy.html"><![CDATA[<hr />
<p>layout: post
title: 아메리카노트 서버 구성 &lt;4&gt; 자동 배포
subtitle: 
categories: wiki
tags: [Server, NaverCloudPlatform, Project, Deploy, GithubActions]
—</p>
<ul>
  <li>프로젝트를 서버에 배포해봤다면 번거롭다는 생각을 한번쯤 해봤을 것 같습니다. 그래서 이번에는 그 배포를 자동으로 진행해보겠습니다.</li>
  <li>자동 배포는 Github Actions의 self-hosted runner를 사용했습니다.
<br />
<br /></li>
</ul>

<h4 id="1-프로젝트-리포지토리에서-github-actions-runner-생성하기">1. 프로젝트 리포지토리에서 Github Actions Runner 생성하기</h4>
<ul>
  <li>프로젝트 리포지토리로 이동하여 Settings - Actions - Runners - New self-hosted runner 화면으로 이동합니다.
<img width="1344" alt="github-actions1" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/c576842e-5e21-4301-a477-b84727d1d967" />
<br />
<br /></li>
</ul>

<h4 id="2-서버에서-명령어-입력하기">2. 서버에서 명령어 입력하기</h4>
<ul>
  <li>서버에 Github Actions runner를 생성해주는 명령어들로 하나씩 차근차근 입력해 줍니다.</li>
  <li>마지막 명령어 실행 중 <strong>Must not run with sudo</strong> 라는 에러 메시지가 발생하면 <code class="language-plaintext highlighter-rouge">export RUNNER_ALLOW_RUNASROOT="1”</code>를 입력한 뒤 재시도하면 됩니다.
<img width="788" alt="github-actions2" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/43dad816-a9ed-4eaa-b137-d76272e537b6" /></li>
  <li>설치 완료 이후 화면
<img width="671" alt="github-actions3" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/9bf0bd39-e89e-468b-9755-6debf9c54ac6" /></li>
  <li>이후 아래 명령어를 입력하면 Github Actions를 수신할 준비가 완료됩니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> ./svc.sh <span class="nb">install
sudo</span> ./svc.sh start
</code></pre></div>    </div>
    <p><br />
<br /></p>
  </li>
</ul>

<h4 id="3-리포지토리에서-actons-workflow-생성">3. 리포지토리에서 Actons workflow 생성</h4>
<ul>
  <li>다시 리포지토리로 돌아가서 Actions 탭에서 왼쪽 상단의 New workflow를 클릭한 뒤 저희 프로젝트에 맞는 ‘Java with Gradle’을 선택하여 워크플로우를 생성합니다.</li>
  <li>이 워크플로우가 바로 Github Actions가 서버에서 수행할 업무들입니다.</li>
  <li>이전 페이지(<a href="https://dajeongdev.github.io/wiki/2024/04/29/deploy-project.html">&lt;3&gt; 프로젝트 배포</a>)에서 직접 설치 및 작성한 것과 동일하게 진행합니다.
    <ul>
      <li>JDK 17 설치</li>
      <li>YML 파일 생성</li>
      <li>Gradle 빌드</li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name: Auto Deploy

on:
  push:
    branches:
      - develop

<span class="nb">jobs</span>:
  build:

    runs-on: self-hosted

    steps:
      <span class="c"># checkout</span>
      - name: Checkout
        uses: actions/checkout@v4

      <span class="c"># JDK setting</span>
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: <span class="s1">'17'</span>
          distribution: <span class="s1">'zulu'</span>

      <span class="c"># secret yml file 생성</span>
      - name: Set secret yml
        run: |
          <span class="nb">mkdir</span> <span class="nt">-p</span> src/main/resources
          <span class="nb">echo</span> <span class="s2">"$"</span> | <span class="nb">base64</span> <span class="nt">--decode</span> <span class="o">&gt;</span> src/main/resources/application-database.yml
          <span class="nb">echo</span> <span class="s2">"$"</span> | <span class="nb">base64</span> <span class="nt">--decode</span> <span class="o">&gt;</span> src/main/resources/application-naver-token.yml
          <span class="nb">echo</span> <span class="s2">"$"</span> | <span class="nb">base64</span> <span class="nt">--decode</span> <span class="o">&gt;</span> src/main/resources/application-security.yml
          find src
        shell: bash

      <span class="c"># Gradle 권한 부여</span>
      - name: Grant permission <span class="k">for </span>gradlew
        run: <span class="nb">chmod</span> +x ./gradlew

      <span class="c"># 테스트 없이 빌드</span>
      - name: Build with Gradle
        run: ./gradlew clean build <span class="nt">-x</span> <span class="nb">test</span>

      <span class="c"># 포트가 사용 중이라면 종료</span>
      - name: Kill 8009 port <span class="k">if </span>exist
        run: |
            <span class="k">if </span><span class="nb">sudo </span>lsof <span class="nt">-i</span> :8009<span class="p">;</span> <span class="k">then
              </span><span class="nb">echo</span> <span class="s2">"Port 8009 is already in use. Killing the process..."</span>
              <span class="nb">sudo kill</span> <span class="nt">-9</span> <span class="sb">`</span><span class="nb">sudo </span>lsof <span class="nt">-t</span> <span class="nt">-i</span>:8009<span class="sb">`</span>
            <span class="k">fi</span>

      <span class="c"># build/libs 폴더 속 jar 파일 실행</span>
      - name: Execute Jar File
        run: |
          <span class="nb">sudo nohup </span>java <span class="nt">-jar</span> build/libs/americano-0.0.1-SNAPSHOT.jar 1&gt;/root/nohup/output.log 2&gt;/root/nohup/error.log &amp;
          <span class="nb">sleep </span>10
</code></pre></div></div>
<ul>
  <li>secret yml 파일의 경우 별도로 필요한 yml들을 Base64로 인코딩하여 리포지토리 Settings → Secrets and variables → Actions에서 Repository Secrets로 설정해주었습니다.
<img width="1340" alt="github-actions4" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/f2771b69-b97f-4255-9e94-6e3c1307921d" /></li>
  <li>또한, Github Actions self-hosted runner에서는 nohup이 적용되지 않아 자꾸 <code class="language-plaintext highlighter-rouge">Unable access to jarfile</code>가 발생하여, 결국 이 부분을 제거했더니 성공적으로 실행되었습니다.
    <ul>
      <li><del>nohup이 적용되지 않는 부분은 추후 원인을 찾아내면 꼭 작성해두도록 하겠습니다!</del> <strong>방법을 찾아서 추가하겠습니다. 또한 어이없게도 제가 nohup 이후에 설정한 게 없기 때문에 로그를 확인할 수 없어 필요하기도 했습니다..🥲</strong>
        <ul>
          <li>nohup의 출력은 프로젝트 내에서 권한 밖이기 때문에 발생한 에러라고 확인이 됩니다. 그래서 프로젝트 밖의 경로로 설정하여 표준 출력과 에러를 구분하여 로그를 전달하는 방식으로 스크립트를 추가했습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 이전
<span class="nb">sudo nohup </span>java <span class="nt">-jar</span> build/libs/americano-0.0.1-SNAPSHOT.jar &amp;
// 현재
 <span class="nb">sudo nohup </span>java <span class="nt">-jar</span> build/libs/americano-0.0.1-SNAPSHOT.jar 1&gt;/root/nohup/output.log 2&gt;/root/nohup/error.log &amp;
</code></pre></div></div>
<p><br />
<br /></p>

<h4 id="참고">참고</h4>
<ul>
  <li>https://e-room.tistory.com/145</li>
  <li>https://be-student.tistory.com/75</li>
  <li><a href="https://velog.io/@bjk1649/github-Action-%EB%A7%8C%EC%9C%BC%EB%A1%9C-%EC%A7%80%EC%86%8D%EC%A0%81-%EB%B0%B0%ED%8F%ACCD-%EB%AA%BB%ED%95%98%EB%82%98">https://velog.io/@bjk1649/github-Action-만으로-지속적-배포CD-못하나</a></li>
  <li>https://green-joo.tistory.com/26</li>
  <li><a href="https://velog.io/@chlee4858/20211205-github%EC%97%90%EC%84%9C-CICD-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0-github-action">https://velog.io/@chlee4858/20211205-github에서-CICD-적용하기-github-action</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Server" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="Deploy" /><summary type="html"><![CDATA[layout: post title: 아메리카노트 서버 구성 &lt;4&gt; 자동 배포 subtitle: categories: wiki tags: [Server, NaverCloudPlatform, Project, Deploy, GithubActions] — 프로젝트를 서버에 배포해봤다면 번거롭다는 생각을 한번쯤 해봤을 것 같습니다. 그래서 이번에는 그 배포를 자동으로 진행해보겠습니다. 자동 배포는 Github Actions의 self-hosted runner를 사용했습니다.]]></summary></entry><entry><title type="html">아메리카노트 서버 구성 &amp;lt;6&amp;gt; HTTPS 적용</title><link href="http://localhost:4000/wiki/2024/04/29/americanote-server6-apply-https-to-the-domain.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;6&amp;gt; HTTPS 적용" /><published>2024-04-29T00:00:00+09:00</published><updated>2024-04-29T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/29/americanote-server6-apply-https-to-the-domain</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/29/americanote-server6-apply-https-to-the-domain.html"><![CDATA[<ul>
  <li>이전 단계에서 진행했던 방화벽에서의 80, 443 포트 허용과 도메인이 있다면 이제 기간은 짧지만 무료로 받을 수 있는 Letsencrypt의 SSL 인증서를 발급 받아보겠습니다.
<br />
<br /></li>
</ul>

<h4 id="ssl-인증서-발급받기">SSL 인증서 발급받기</h4>
<ul>
  <li>인증서를 발급받기 위해 letsencrypt의 certbot을 설치해주고, 인증서를 발급받습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update <span class="c"># 패키지 업데이트</span>
<span class="nb">sudo </span>apt <span class="nb">install </span>certbot python3-certbot-nginx
<span class="nb">sudo </span>certbot <span class="nt">--nginx</span> <span class="nt">-d</span> 도메인이름 <span class="nt">-d</span> www.도메인이름
</code></pre></div></div>

<ul>
  <li>첫 실행 시에는 이메일을 입력하고 약관에 동의해야 합니다.</li>
  <li>이후 certbot이 letsencrypt 서버와 통신 중 도메인이 유효한치 확인하는 과정을 거칩니다.
    <ul>
      <li>저는 이 부분에서 에러가 참 많이 발생했는데요 ㅎㅎ 하나씩 살펴보겠습니다.
        <ol>
          <li><strong>/well-known/acme-challenge/ 폴더가 허용되지 않았습니다.</strong>
            <ul>
              <li>
                <p>이 부분은 Nginx에서 적용하는 부분이라 이전 단계에서 만들었던 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/도메인이름</code> 파일에서 추가해주었습니다.</p>

                <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  server <span class="o">{</span>
          listen 80 default_server<span class="p">;</span>
          listen <span class="o">[</span>::]:80 default_server<span class="p">;</span>
                
          server_name 도메인이름 www.도메인이름<span class="p">;</span>
                
          location ~ /<span class="se">\.</span>well-known/acme-challenge/ <span class="o">{</span>
          allow all<span class="p">;</span>
          root /var/www/letsencrypt<span class="p">;</span>
          <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>                </div>
              </li>
            </ul>
          </li>
          <li><strong>도메인에 A 레코드를 적용되어 있지 않았습니다.</strong>
            <ul>
              <li>A 레코드 적용을 위해 NCP에서 Global Domain에 도메인을 추가하고, A 레코드를 추가해주었습니다.
  <img width="679" alt="https1" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/3abce503-be85-43fe-8531-612c95578743" /></li>
              <li>하지만 이 Global Domain의 네임서버를 카페24의 도메인에 설정해주는 과정에서 24시간이 걸린다는 소식에 아주 멘탈이 탈탈 털릴 뻔 했지만… 다행히 12시간 정도 뒤에 사용이 가능했습니다😂
  <img width="544" alt="https2" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/8f6df708-93fa-4e43-8709-e2ad85b0c689" /></li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p><img width="770" alt="https3" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/f52a2ee6-ea91-475c-ba0e-8252c28a2993" /></p>
<ul>
  <li>그리하여 드디어 간절히 기다리던 발급 성공 화면을 보게 되면 SSL 발급에 성공한 겁니다.</li>
  <li>이제 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/도메인이름</code> 파일에 접근해보면 자동으로 SSL이 적용된 것을 확인할 수 있습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server <span class="o">{</span>
        listen  443 ssl<span class="p">;</span>
        server_name americanote.store www.americanote.store<span class="p">;</span>

        <span class="c">#access_log /var/log/nginx/proxy/access.log;</span>
        <span class="c">#error_log /var/log/nginx/proxy/error.log;</span>

        ssl_certificate /etc/letsencrypt/live/americanote.store/fullchain.pem<span class="p">;</span>
        ssl_certificate_key /etc/letsencrypt/live/americanote.store/privkey.pem<span class="p">;</span>

        location / <span class="o">{</span> <span class="c"># 추가</span>
                proxy_pass http://127.0.0.1:8009<span class="p">;</span>

        <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>참고로 <code class="language-plaintext highlighter-rouge">location / { … }</code> 부분까지 설정해주어야 현재 서버의 8009로 실행되고 있는 프로세스로 프록시가 요청을 전달해줍니다.
<br />
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li><a href="https://velog.io/@curiosity806/nginx-Lets-Encrypt-SSL-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89">https://velog.io/@curiosity806/nginx-Lets-Encrypt-SSL-인증서-발급</a></li>
  <li><a href="https://jaehyeon48.github.io/nginx/configure-nginx-on-ubuntu-2004">Ubuntu 20.04에서 Nginx 설치 및 설정하기</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="MySQL" /><category term="DataBase" /><summary type="html"><![CDATA[이전 단계에서 진행했던 방화벽에서의 80, 443 포트 허용과 도메인이 있다면 이제 기간은 짧지만 무료로 받을 수 있는 Letsencrypt의 SSL 인증서를 발급 받아보겠습니다.]]></summary></entry><entry><title type="html">아메리카노트 서버 구성 &amp;lt;1&amp;gt; Linux 서버 생성</title><link href="http://localhost:4000/wiki/2024/04/28/americanote-server1-create-linux-server.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;1&amp;gt; Linux 서버 생성" /><published>2024-04-28T00:00:00+09:00</published><updated>2024-04-28T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/28/americanote-server1-create-linux-server</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/28/americanote-server1-create-linux-server.html"><![CDATA[<h4 id="배경">배경</h4>
<ul>
  <li>비사이드 포텐데이403 프로젝트를 진행하면서 Linux 서버를 생성하기 위해 순서대로 정리해봤습니다.
<br />
<br /></li>
</ul>

<h4 id="1-os-선택">1. OS 선택</h4>
<ul>
  <li>레퍼런스가 많고 지속적으로 업데이트가 되고 있는 <strong>Ubuntu</strong>로 선택함
<br />
<br /></li>
</ul>

<h4 id="2-vpcvirtual-private-cloud-설정">2. VPC(Virtual Private Cloud) 설정</h4>
<ul>
  <li>전용 네트워크</li>
  <li>필수
    <ul>
      <li>이름, IP 주소 범위
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="3-subnet-설정">3. Subnet 설정</h4>
<ul>
  <li>VPC 내에 세분화된 격리 공간 제공</li>
  <li>필수
    <ul>
      <li>이름, VPC, IP 주소 범위(VPC 범위 내), 가용 Zone, Network ACL, Internet Gateway 전용 여부(public), 용도
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="4-서버-생성">4. 서버 생성</h4>
<ul>
  <li>서버 타입: Standard</li>
  <li>서버 스펙: s2-g3(vCPU 2EA, Memory 8GB)</li>
  <li>스토리지: CB1 (기본 스토리지, 10GB)</li>
  <li>서버 인증키(pem)
    <ul>
      <li>잘 보관해두기
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="5-acg방화벽-설정">5. ACG(방화벽) 설정</h4>
<ul>
  <li>22
    <ul>
      <li>접속할 PC</li>
      <li>IP 입력</li>
      <li><strong>팀원들 IP 입력 필요</strong> ⭐</li>
    </ul>
  </li>
  <li>80, 443
    <ul>
      <li>URL 링크로 접속</li>
      <li>클라이언트를 위한 포트</li>
      <li>80: HTTP</li>
      <li>443: HTTPS</li>
    </ul>
  </li>
  <li>81
    <ul>
      <li>Nginx Proxy Manager의 접속을 위한 포트</li>
    </ul>
  </li>
  <li>3306
    <ul>
      <li>DB 접속
<br />
<br /></li>
    </ul>
  </li>
</ul>

<p><strong>참고</strong></p>
<ul>
  <li>https://velog.io/@ejh990521/CentOS-vs-Ubuntu</li>
  <li>https://docs.3rdeyesys.com/compute/ncloud_compute_server_vpc_create.html</li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Server" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="Linux" /><summary type="html"><![CDATA[배경 비사이드 포텐데이403 프로젝트를 진행하면서 Linux 서버를 생성하기 위해 순서대로 정리해봤습니다.]]></summary></entry><entry><title type="html">배열 오름차순/내림차순 정렬</title><link href="http://localhost:4000/wiki/2024/04/22/array-sort-asc-desc.html" rel="alternate" type="text/html" title="배열 오름차순/내림차순 정렬" /><published>2024-04-22T00:00:00+09:00</published><updated>2024-04-22T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/22/array-sort-asc-desc</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/22/array-sort-asc-desc.html"><![CDATA[<h3 id="배열-오름차순내림차순-정렬">배열 오름차순/내림차순 정렬</h3>
<h4 id="배경">배경</h4>
<p>코딩테스트 문제로 자주 등장하는 배열의 오름차순/내림차순 정렬에 대해 정리해두겠습니다.
<br />
<br /></p>

<h4 id="1-오름차순-정렬">&lt;1&gt; 오름차순 정렬</h4>
<p><img src="https://dajeongdev.github.io/assets/images/posts/arrays-sort.png" /></p>
<ul>
  <li>오름차순 정렬은 아주 간단하다. Arrays 클래스의 sort() 메소드를 사용하면 된다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">A</span><span class="o">);</span> <span class="c1">// 결과: A = {3, 3, 4}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="2-내림차순-정렬">&lt;2&gt; 내림차순 정렬</h4>
<p><img src="https://dajeongdev.github.io/assets/images/posts/arrays-sort-collections.png" /></p>
<ul>
  <li>내림차순 정렬도 어렵진 않지만, 한 가지 주의할 점은 Comparator&lt;?&gt;로 받는 T가 제네릭 클래스로 받는 객체이기 때문에 int 같은 Primitive 타입은 사용할 수 없다는 것이다.</li>
  <li>그래서 만약 int 배열을 내림차순 정렬하기 위해 Arrays.sort()를 사용한다면 반드시 Integer 타입의 배열로 변환하는 과정이 필요하다.
    <ul>
      <li>하지만 변환하는 과정이 생각보다 효율적이진 않으니 간단한 알고리즘이라면 다른 방법을 사용해보는 것도 좋다. (실제로 코딩테스트 문제에서 시도했다가 효율성 점수가 정말 낮게 나온 적이 있다..)</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="no">A</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">());</span> <span class="c1">// 결과: A = {5, 4, 3};</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="참고">참고</h4>
<ul>
  <li>int[]에서 Integer[]로 변환</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="no">A</span><span class="o">).</span><span class="na">boxed</span><span class="o">().</span><span class="na">toArray</span><span class="o">(</span><span class="nc">Integer</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>Integer[]에서 int[]로 변환</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="no">A</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="no">A</span><span class="o">).</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">intValue</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
</code></pre></div></div>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="Arrays" /><category term="Sort" /><summary type="html"><![CDATA[배열 오름차순/내림차순 정렬 배경 코딩테스트 문제로 자주 등장하는 배열의 오름차순/내림차순 정렬에 대해 정리해두겠습니다.]]></summary></entry><entry><title type="html">비사이드 포텐데이 403 프로젝트에서 Naver Cloud Platform 사용 후기</title><link href="http://localhost:4000/blog/2024/04/19/naver-cloud-review.html" rel="alternate" type="text/html" title="비사이드 포텐데이 403 프로젝트에서 Naver Cloud Platform 사용 후기" /><published>2024-04-19T00:00:00+09:00</published><updated>2024-04-19T00:00:00+09:00</updated><id>http://localhost:4000/blog/2024/04/19/naver-cloud-review</id><content type="html" xml:base="http://localhost:4000/blog/2024/04/19/naver-cloud-review.html"><![CDATA[<h4 id="q-프로젝트를-소개해-주세요">Q. 프로젝트를 소개해 주세요.</h4>
<p><img src="https://github.com/dajeongdev/Americanote/assets/61612976/6956afbf-def5-4fc8-af36-4e9689304868" alt="중간산출물_Americanote" />
<br />
내 취향에 딱 맞는 아메리카노 카페 찾기 서비스 Americanote(아메리카노트)입니다.<br />
“카페 리뷰는 많은데 정작 커피 맛은 어떤지 모르겠어💦” <br />
“꼭 방문해서 먹어보고 커피 맛을 알아야 할까?” <br />
“내 취향에 딱 맞는 아메리카노를 먹고싶어!” <br />
그래서 만들었습니다! Americanote는 카페를 방문하지 않고도 커피의 향, 강도, 산미를 알 수 있어요!
<br /><br /></p>

<p>🖥️   <a href="https://americanote.vercel.app">서비스 이용해보러 가기</a> <br />
<img src="https://github.com/dajeongdev/Americanote/assets/61612976/89d0ce20-287b-450a-a54a-2cfec5efb661" style="width:16px; vertical-align:unset; float:left;" />   <a href="https://night-geography-507.notion.site/Americanote-c95e62599ec348c48893a668d5dcfb5c?pvs=4">노션 구경하러 가기</a><br />
<img src="https://github.com/dajeongdev/Americanote/assets/61612976/a8a63803-8b82-4a34-b98e-f9b8b58ae2a7" style="width:16px; vertical-align:unset; float:left;" />   <a href="https://github.com/dajeongdev/Americanote">Github으로 프로젝트 확인하기</a><br />
📙   <a href="https://www.americanote.store/swagger-ui/index.html">Swagger 문서 확인하러 가기</a>
<br /><br /></p>

<h4 id="q-ncloud-서비스를-어떻게-적용-하였나요">Q. Ncloud 서비스를 어떻게 적용 하였나요?</h4>
<p><img width="769" alt="service-architecture" src="https://github.com/dajeongdev/Americanote/assets/61612976/f1a16aab-bf3c-4206-8b0b-79e581bc2768" /><br />
비사이드 포텐데이에서는 Green Developers 프로그램에 참여하면서 Naver Cloud로부터 크레딧 지원을 받아 다양한 서비스를 이용할 수 있었습니다. 
저희 프로젝트에서는 그중 Server와 Cloud DB 그리고 Global Domain을 사용하여 아주 간단한 인프라를 구축했습니다.
<br /><br />
🌐   <a href="https://night-geography-507.notion.site/1-Linux-18bf283cbe204de5aa9f60d93f579867?pvs=4">자세한 서버 구축 과정 보러가기</a> 
<br /><br /></p>

<h4 id="q-ncloud-사용-중-특히-만족했던-점과-아쉬웠던-점은-무엇인가요">Q. Ncloud 사용 중 특히 만족했던 점과, 아쉬웠던 점은 무엇인가요?</h4>
<p>이전까지 AWS만 사용해봤기 때문에 아예 경험이 없던 Naver Cloud로 서버와 데이터베이스를 구성하는 게 조금 걱정이 됐었습니다. 그런 걱정에도 불구하고 공식 홈페이지에서 사용 가이드가 잘 작성되어 있어 생각보다 빠르게 서버와 데이터베이스를 생성할 수 있었고, 크레딧에 대해 남은 금액에 대해 이메일로 알림을 보내줘서 쉽게 확인할 수 있는 점이 아주 만족스러웠습니다.
그렇지만 Global Domain 적용을 위해 레퍼런스를 찾던 중 타사에 비해 레퍼런스가 적어서 시간이 조금 더 걸렸던 부분이 아주 약간은 아쉬웠습니다. ㅎㅎ
<br /><br /></p>

<h4 id="q-green-developers-프로그램-참여-소감">Q. Green Developers 프로그램 참여 소감</h4>
<p>AWS 프리티어처럼 제한된 용량 안에서 개발하는 것보다 진짜 실무를 경험할 수 있도록 다양한 Naver Cloud 서비스를 사용해 볼 수 있어서 정말 좋은 경험을 한 것 같습니다. 앞으로도 Naver Cloud에 대해 더 공부해 보고 싶은 계기가 되었습니다. 이런 프로그램 만들어주셔서 감사합니다!</p>]]></content><author><name>Dajeong Park</name></author><category term="blog" /><category term="NaverCloud" /><category term="NaverCloudPlatform" /><category term="프로젝트" /><category term="후기" /><summary type="html"><![CDATA[Q. 프로젝트를 소개해 주세요. 내 취향에 딱 맞는 아메리카노 카페 찾기 서비스 Americanote(아메리카노트)입니다. “카페 리뷰는 많은데 정작 커피 맛은 어떤지 모르겠어💦” “꼭 방문해서 먹어보고 커피 맛을 알아야 할까?” “내 취향에 딱 맞는 아메리카노를 먹고싶어!” 그래서 만들었습니다! Americanote는 카페를 방문하지 않고도 커피의 향, 강도, 산미를 알 수 있어요!]]></summary></entry><entry><title type="html">문자열 대치</title><link href="http://localhost:4000/wiki/2024/03/17/string-replacement.html" rel="alternate" type="text/html" title="문자열 대치" /><published>2024-03-17T00:00:00+09:00</published><updated>2024-03-17T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/03/17/string-replacement</id><content type="html" xml:base="http://localhost:4000/wiki/2024/03/17/string-replacement.html"><![CDATA[<h3 id="종류">종류</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">replace()</code></li>
  <li><code class="language-plaintext highlighter-rouge">replaceAll()</code></li>
  <li><code class="language-plaintext highlighter-rouge">replaceFirst()</code>
<br />
<br /></li>
</ol>

<h3 id="replacecharsequence-target-charsequence-replacement">replace(CharSequence target, CharSequence replacement)</h3>
<ul>
  <li>일치하는 문자열(target)을 새로운 문자열(replacement)로 치환한다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"가/나/다/라/마/바/사"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"/"</span><span class="o">,</span> <span class="s">","</span><span class="o">));</span> <span class="c1">// 가,나,다,라,마,바,사</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h3 id="replaceallstring-regex-string-replacement">replaceAll(String regex, String replacement)</h3>
<ul>
  <li>일치하는 정규 표현식(regex)을 새로운 문자열(replacement)로 <strong>전부</strong> 치환한다.
    <ul>
      <li>replace()와 유사하지만, <code class="language-plaintext highlighter-rouge">.</code>(온점) 같은 경우 정규 표현식으로 모든 문자를 의미하기 때문에 모든 문자열이 치환될 수 있다.
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"가.나.다.라.마.바.사"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str2</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"."</span><span class="o">,</span> <span class="s">","</span><span class="o">));</span> <span class="c1">// 가,나,다,라,마,바,사</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str2</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"."</span><span class="o">,</span> <span class="s">","</span><span class="o">));</span> <span class="c1">// ,,,,,,,,,,,,,</span>
</code></pre></div>        </div>
        <p><br /></p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="replace와-replaceall">replace()와 replaceAll()</h3>
<ul>
  <li>두 메소드는 일반 문자열 리터럴을 비교할 땐 실행 결과에 차이가 없다.</li>
  <li>하지만 replaceAll()은 문자열 대치에 정규식을 사용하여 조금 더 구체적인 검증이 가능하다.
<br />
<br /></li>
</ul>

<h3 id="replacefirststring-target-string-replacement">replaceFirst(String target, String replacement)</h3>
<ul>
  <li>첫번째로 일치하는 문자열(target)를 대체할 문자(replacement)로 치환한다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"가/나/다/라/마/바/사"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"/"</span><span class="o">,</span> <span class="s">","</span><span class="o">));</span> <span class="c1">// 가,나/다/라/마/바/사</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h3 id="실무-사용-예시">실무 사용 예시</h3>
<ul>
  <li>해시태그가 포함되어 있는 내용에 바꾸고 싶은 내용이 해시태그마다 다를 때 사용한다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">contents</span> <span class="o">=</span> <span class="n">reportMapper</span><span class="o">.</span><span class="na">findReportTemplate</span><span class="o">(</span><span class="mi">60001</span><span class="o">);</span>
<span class="n">contents</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"#"</span><span class="o">,</span> <span class="n">childName</span><span class="o">)</span>
              <span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"#"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">progress</span><span class="o">.</span><span class="na">getCount</span><span class="o">()))</span>
              <span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"#"</span><span class="o">,</span> <span class="n">progress</span><span class="o">.</span><span class="na">getPercent</span><span class="o">())</span>
              <span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"#"</span><span class="o">,</span> <span class="n">previous</span><span class="o">)</span>
              <span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"#"</span><span class="o">,</span> <span class="n">average</span><span class="o">);</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li>https://coding-factory.tistory.com/128</li>
  <li>031724 추가
    <ul>
      <li>https://bada744.tistory.com/16</li>
    </ul>
  </li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="String" /><category term="Method" /><summary type="html"><![CDATA[종류 replace() replaceAll() replaceFirst()]]></summary></entry><entry><title type="html">Queue</title><link href="http://localhost:4000/wiki/2024/03/05/queue.html" rel="alternate" type="text/html" title="Queue" /><published>2024-03-05T00:00:00+09:00</published><updated>2024-03-05T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/03/05/queue</id><content type="html" xml:base="http://localhost:4000/wiki/2024/03/05/queue.html"><![CDATA[<h3 id="queue선형-큐">Queue(선형 큐)</h3>
<h4 id="특징">특징</h4>
<ul>
  <li>줄 서있는 것처럼 선입선출(FIFO) 형태의 자료구조</li>
  <li>정해진 한 곳(top)을 통해서 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에서 삽입 작업, 다른 쪽에서 삭제 작업이 양쪽으로 이루어진다.</li>
  <li>큐의 뒤(rear)에서만 삽입(enqueue)하고, 큐의 앞(front)에서는 삭제(dequeue)만 이루어진다.</li>
  <li>자바에서는 스택을 Stack 클래스로 구현하여 제공하지만, 큐는 Queue 인터페이스만 있고 별도의 클래스가 없다. 그래서 Queue 인터페이스를 구현한 클래스를 사용해야 한다.
<br /></li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>선형 큐에서 삽입/삭제를 반복하다 보면, rear가 맨 마지막 인덱스를 가리키고 앞에는 비어있을 수 있지만 이를 꽉 찼다고 인식한다. 데이터를 삭제할 때마다 한 칸 앞으로 이동시키는 것이 아니라 인덱스 단위로 큐의 연산을 진행하기 때문에 이러한 문제점이 있다. 이러한 단점을 보완하기 위해 Circular Queue(원형 큐)가 생겨났다.
<br /></li>
</ul>

<h4 id="메소드">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="n">자료형</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>
<p><strong><code class="language-plaintext highlighter-rouge">boolean add(E value)</code></strong></p>
<ul>
  <li>value 삽입 성공 시 true, 실패 시 Exception 발생</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean offer(E value)</code></strong></p>
<ul>
  <li>value 삽입 성공 시 true, 실패 시 false 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E remove(E value)</code></strong></p>
<ul>
  <li>value 삭제 성공 시 삭제된 value, 공백 큐라면 Exception(NoSuchElementException) 발생</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean remove(E value)</code></strong></p>
<ul>
  <li>해당 value가 존재하면 삭제 후 true, 존재하지 않으면 false 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E poll(E value)</code></strong></p>
<ul>
  <li>value 삭제 성공 시 삭제된 value, 공백 큐라면 null 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E element()</code></strong></p>
<ul>
  <li>head에 위치한 value를 리턴하거나, 공백 큐라면 Exception(NoSuchElementException) 발생</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E peek()</code></strong></p>
<ul>
  <li>head에 위치한 value를 리턴하거나, 공백 큐라면 null 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">void clear()</code></strong></p>
<ul>
  <li>해당 큐를 초기화 함(공백 큐로 만듦)</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">int size()</code></strong></p>
<ul>
  <li>큐의 사이즈를 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean contains(E value)</code></strong></p>
<ul>
  <li>value가 존재하면 true, 없으면 false 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean isEmpty()</code></strong></p>
<ul>
  <li>공백 큐라면 true, 아니라면 false 리턴
<br /></li>
</ul>

<h4 id="활용">활용</h4>
<ul>
  <li>큐는 주로 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용한다.</li>
  <li>우선순위가 같은 작업 예약 (프린터의 인쇄 대기열)
    <ul>
      <li>작업 스케줄링</li>
    </ul>
  </li>
  <li>은행 업무</li>
  <li>콜센터 고객 대기 시간</li>
  <li>프로세스 관리</li>
  <li>너비 우선 탐색(BFS, Breadth-First Search) 구현</li>
  <li>캐시(Cache) 구현</li>
  <li>버퍼: 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역 (입출력 및 네트워크에서 사용)
<br />
<br /></li>
</ul>

<h3 id="circular-queue">Circular Queue</h3>
<h4 id="특징-1">특징</h4>
<ul>
  <li>1차원 배열을 사용하여 구현한다.</li>
  <li>초기 front와 rear는 맨 처음 인덱스에 위치한다.</li>
  <li>front와 rear를 회전시키기 위해서 모듈러(%) 연산을 사용한다.</li>
  <li><br /></li>
</ul>

<h4 id="주요-연산">주요 연산</h4>
<ul>
  <li><strong>enQueue</strong>: (rear + 1) % (배열의 크기)
    <ul>
      <li>만약 rear + 1이 front와 같으면 해당 큐는 꽉 찬 것이다.</li>
      <li>배열의 크기가 11인 배열의 index 10까지 모두 채우면, 다음 rear는 11이 아니라 0이 된다.</li>
    </ul>
  </li>
  <li><strong>deQueue</strong>: (front + 1) % (배열의 크기)</li>
  <li><strong>size</strong>: (배열의 크기 + rear - front) % (배열의 크기)
    <ul>
      <li>주의사항: rear == front(가득 찼을 때)도 마찬가지로 0이 된다.</li>
    </ul>
  </li>
  <li><strong>full</strong>: (rear + 1) % (배열의 크기) == front</li>
  <li><strong>empty</strong>: rear == front
<br />
<br /></li>
</ul>

<h3 id="priority-queue">Priority Queue</h3>
<h4 id="특징-2">특징</h4>
<ul>
  <li>Queue 인터페이스를 구현하였다.</li>
  <li>저장한 순서에 상관없이 우선순위(priority)가 높은 것부터 꺼낸다.</li>
  <li>null을 저장하면 NPE가 발생한다.</li>
  <li>배열을 사용하며, 각 요소를 힙이라는 자료구조의 형태로 저장한다. (JVM의 힙과 자료구조의 힙은 다르다!)</li>
  <li>지정하지 않으면 숫자가 작을 수록 우선순위가 높다.</li>
  <li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html">Priority Queue API</a>
<br /></li>
</ul>

<h4 id="구현-방법">구현 방법</h4>
<ul>
  <li>배열을 기반으로 구현하는 방법</li>
  <li>연결 리스트를 기반으로 구현하는 방법</li>
  <li>힙(heap)을 이용하는 방법</li>
  <li>배열이나 연결 리스트로 구현할 경우 간단하게 구현이 가능하지만, 데이터 삽입과 삭제 과정에서 데이터를 한 칸씩 당기거나 밀어야 하는 연산을 계속해야 한다. 또 삽입의 위치를 찾기 위해 배열에 저장된 모든 데이터와 우선순위를 비교해야 한다.</li>
  <li>연결 리스트의 경우, 삽입의 위치를 찾기 위해 첫번째 노트부터 싲가하여 마지막 노드에 저장된 데이터와 우선순위를 비교해야 할 수도 있다. (성능 저하) 그래서 일반적으로 힙을 이용하여 구현한다.
<br />
<br /></li>
</ul>

<h3 id="dequeue">Dequeue</h3>
<h4 id="특징-3">특징</h4>
<ul>
  <li>데이터의 추가와 삭제를 양쪽 끝에서 가능하게 하는 자료구조 (큐와 스택을 합친 형태로 생각할 수 있음)</li>
  <li>연속적인 메모리를 기반으로 하는 ‘시퀀스 컨테이너’이다. 따라서 임의 접근 반복자를 제공한다.</li>
  <li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html">Deque API</a>
<br /></li>
</ul>

<h4 id="유형">유형</h4>
<ul>
  <li><strong>scroll</strong>: 입력 제한 덱, 입력이 한쪽으로만 일어나도록 제한</li>
  <li><strong>self</strong>: 출력 제한 덱, 출력이 한쪽으로만 일어나도록 제한
<br /></li>
</ul>

<h4 id="활용-1">활용</h4>
<ul>
  <li>스케줄링: 스케줄링이 복잡해질 수록 스택과 덱보다 효율이 잘 나오는 경우가 있다.</li>
  <li>우선순위 조절: 한 방향으로만 삽입/삭제가 가능한 스택과 큐와 달리 양방향으로 삽입/삭제가 자유롭다.
<br />
<br /></li>
</ul>

<h3 id="stack과-queue의-차이점">Stack과 Queue의 차이점</h3>
<ul>
  <li>아이템을 삭제할 때 가장 큰 차이점이 있다.</li>
  <li>스택은 가장 마지막에 추가된 item을 삭제하고, 큐는 가장 처음 들어와있던 item을 삭제한다.</li>
  <li>스택과 큐 모두 Peek을 사용할 수 있다. Peak 연산은 자료구조의 변화를 주지 않고, pop이나 dequeue를 할 때 리턴되는 item을 리턴할 수 있다.
<br />
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li>https://devuna.tistory.com/22</li>
  <li>https://kwin0825.tistory.com/157</li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="DataStructure" /><category term="Queue" /><summary type="html"><![CDATA[Queue(선형 큐) 특징 줄 서있는 것처럼 선입선출(FIFO) 형태의 자료구조 정해진 한 곳(top)을 통해서 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에서 삽입 작업, 다른 쪽에서 삭제 작업이 양쪽으로 이루어진다. 큐의 뒤(rear)에서만 삽입(enqueue)하고, 큐의 앞(front)에서는 삭제(dequeue)만 이루어진다. 자바에서는 스택을 Stack 클래스로 구현하여 제공하지만, 큐는 Queue 인터페이스만 있고 별도의 클래스가 없다. 그래서 Queue 인터페이스를 구현한 클래스를 사용해야 한다.]]></summary></entry></feed>