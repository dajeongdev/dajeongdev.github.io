<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2024-04-28T23:34:13+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Every Single Day</title><subtitle></subtitle><author><name>Dajeong Park</name></author><entry><title type="html">아메리카노트 서버 구성 &amp;lt;1&amp;gt; Linux 서버 생성</title><link href="http://localhost:4000/wiki/2024/04/28/create-linux-server.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;1&amp;gt; Linux 서버 생성" /><published>2024-04-28T00:00:00+09:00</published><updated>2024-04-28T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/28/create-linux-server</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/28/create-linux-server.html"><![CDATA[<h4 id="배경">배경</h4>
<ul>
  <li>비사이드 포텐데이403 프로젝트를 진행하면서 Linux 서버를 생성하기 위해 순서대로 정리해봤습니다.
<br />
<br /></li>
</ul>

<h4 id="1-os-선택">1. OS 선택</h4>
<ul>
  <li>레퍼런스가 많고 지속적으로 업데이트가 되고 있는 <strong>Ubuntu</strong>로 선택함
<br />
<br /></li>
</ul>

<h4 id="2-vpcvirtual-private-cloud-설정">2. VPC(Virtual Private Cloud) 설정</h4>
<ul>
  <li>전용 네트워크</li>
  <li>필수
    <ul>
      <li>이름, IP 주소 범위
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="3-subnet-설정">3. Subnet 설정</h4>
<ul>
  <li>VPC 내에 세분화된 격리 공간 제공</li>
  <li>필수
    <ul>
      <li>이름, VPC, IP 주소 범위(VPC 범위 내), 가용 Zone, Network ACL, Internet Gateway 전용 여부(public), 용도
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="4-서버-생성">4. 서버 생성</h4>
<ul>
  <li>서버 타입: Standard</li>
  <li>서버 스펙: s2-g3(vCPU 2EA, Memory 8GB)</li>
  <li>스토리지: CB1 (기본 스토리지, 10GB)</li>
  <li>서버 인증키(pem)
    <ul>
      <li>잘 보관해두기
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="5-acg방화벽-설정">5. ACG(방화벽) 설정</h4>
<ul>
  <li>22
    <ul>
      <li>접속할 PC</li>
      <li>IP 입력</li>
      <li><strong>팀원들 IP 입력 필요</strong> ⭐</li>
    </ul>
  </li>
  <li>80, 443
    <ul>
      <li>URL 링크로 접속</li>
      <li>클라이언트를 위한 포트</li>
      <li>80: HTTP</li>
      <li>443: HTTPS</li>
    </ul>
  </li>
  <li>81
    <ul>
      <li>Nginx Proxy Manager의 접속을 위한 포트</li>
    </ul>
  </li>
  <li>3306
    <ul>
      <li>DB 접속
<br />
<br /></li>
    </ul>
  </li>
</ul>

<p><strong>참고</strong></p>
<ul>
  <li>https://velog.io/@ejh990521/CentOS-vs-Ubuntu</li>
  <li>https://docs.3rdeyesys.com/compute/ncloud_compute_server_vpc_create.html</li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Server" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="Linux" /><summary type="html"><![CDATA[배경 비사이드 포텐데이403 프로젝트를 진행하면서 Linux 서버를 생성하기 위해 순서대로 정리해봤습니다.]]></summary></entry><entry><title type="html">배열 오름차순/내림차순 정렬</title><link href="http://localhost:4000/wiki/2024/04/22/array-sort-asc-desc.html" rel="alternate" type="text/html" title="배열 오름차순/내림차순 정렬" /><published>2024-04-22T00:00:00+09:00</published><updated>2024-04-22T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/22/array-sort-asc-desc</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/22/array-sort-asc-desc.html"><![CDATA[<h3 id="배열-오름차순내림차순-정렬">배열 오름차순/내림차순 정렬</h3>
<h4 id="배경">배경</h4>
<p>코딩테스트 문제로 자주 등장하는 배열의 오름차순/내림차순 정렬에 대해 정리해두겠습니다.
<br />
<br /></p>

<h4 id="1-오름차순-정렬">&lt;1&gt; 오름차순 정렬</h4>
<p><img src="https://dajeongdev.github.io/assets/images/posts/arrays-sort.png" /></p>
<ul>
  <li>오름차순 정렬은 아주 간단하다. Arrays 클래스의 sort() 메소드를 사용하면 된다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">A</span><span class="o">);</span> <span class="c1">// 결과: A = {3, 3, 4}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="2-내림차순-정렬">&lt;2&gt; 내림차순 정렬</h4>
<p><img src="https://dajeongdev.github.io/assets/images/posts/arrays-sort-collections.png" /></p>
<ul>
  <li>내림차순 정렬도 어렵진 않지만, 한 가지 주의할 점은 Comparator&lt;?&gt;로 받는 T가 제네릭 클래스로 받는 객체이기 때문에 int 같은 Primitive 타입은 사용할 수 없다는 것이다.</li>
  <li>그래서 만약 int 배열을 내림차순 정렬하기 위해 Arrays.sort()를 사용한다면 반드시 Integer 타입의 배열로 변환하는 과정이 필요하다.
    <ul>
      <li>하지만 변환하는 과정이 생각보다 효율적이진 않으니 간단한 알고리즘이라면 다른 방법을 사용해보는 것도 좋다. (실제로 코딩테스트 문제에서 시도했다가 효율성 점수가 정말 낮게 나온 적이 있다..)</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="no">A</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">());</span> <span class="c1">// 결과: A = {5, 4, 3};</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="참고">참고</h4>
<ul>
  <li>int[]에서 Integer[]로 변환</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="no">A</span><span class="o">).</span><span class="na">boxed</span><span class="o">().</span><span class="na">toArray</span><span class="o">(</span><span class="nc">Integer</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>Integer[]에서 int[]로 변환</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="no">A</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="no">A</span><span class="o">).</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">intValue</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
</code></pre></div></div>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="Arrays" /><category term="Sort" /><summary type="html"><![CDATA[배열 오름차순/내림차순 정렬 배경 코딩테스트 문제로 자주 등장하는 배열의 오름차순/내림차순 정렬에 대해 정리해두겠습니다.]]></summary></entry><entry><title type="html">비사이드 포텐데이 403 프로젝트에서 Naver Cloud Platform 사용 후기</title><link href="http://localhost:4000/blog/2024/04/19/naver-cloud-review.html" rel="alternate" type="text/html" title="비사이드 포텐데이 403 프로젝트에서 Naver Cloud Platform 사용 후기" /><published>2024-04-19T00:00:00+09:00</published><updated>2024-04-19T00:00:00+09:00</updated><id>http://localhost:4000/blog/2024/04/19/naver-cloud-review</id><content type="html" xml:base="http://localhost:4000/blog/2024/04/19/naver-cloud-review.html"><![CDATA[<h4 id="q-프로젝트를-소개해-주세요">Q. 프로젝트를 소개해 주세요.</h4>
<p><img src="https://github.com/dajeongdev/Americanote/assets/61612976/6956afbf-def5-4fc8-af36-4e9689304868" alt="중간산출물_Americanote" />
<br />
내 취향에 딱 맞는 아메리카노 카페 찾기 서비스 Americanote(아메리카노트)입니다.<br />
“카페 리뷰는 많은데 정작 커피 맛은 어떤지 모르겠어💦” <br />
“꼭 방문해서 먹어보고 커피 맛을 알아야 할까?” <br />
“내 취향에 딱 맞는 아메리카노를 먹고싶어!” <br />
그래서 만들었습니다! Americanote는 카페를 방문하지 않고도 커피의 향, 강도, 산미를 알 수 있어요!
<br /><br /></p>

<p>🖥️   <a href="https://americanote.vercel.app">서비스 이용해보러 가기</a> <br />
<img src="https://github.com/dajeongdev/Americanote/assets/61612976/89d0ce20-287b-450a-a54a-2cfec5efb661" style="width:16px; vertical-align:unset; float:left;" />   <a href="https://night-geography-507.notion.site/Americanote-c95e62599ec348c48893a668d5dcfb5c?pvs=4">노션 구경하러 가기</a><br />
<img src="https://github.com/dajeongdev/Americanote/assets/61612976/a8a63803-8b82-4a34-b98e-f9b8b58ae2a7" style="width:16px; vertical-align:unset; float:left;" />   <a href="https://github.com/dajeongdev/Americanote">Github으로 프로젝트 확인하기</a><br />
📙   <a href="https://www.americanote.store/swagger-ui/index.html">Swagger 문서 확인하러 가기</a>
<br /><br /></p>

<h4 id="q-ncloud-서비스를-어떻게-적용-하였나요">Q. Ncloud 서비스를 어떻게 적용 하였나요?</h4>
<p><img width="769" alt="service-architecture" src="https://github.com/dajeongdev/Americanote/assets/61612976/f1a16aab-bf3c-4206-8b0b-79e581bc2768" /><br />
비사이드 포텐데이에서는 Green Developers 프로그램에 참여하면서 Naver Cloud로부터 크레딧 지원을 받아 다양한 서비스를 이용할 수 있었습니다. 
저희 프로젝트에서는 그중 Server와 Cloud DB 그리고 Global Domain을 사용하여 아주 간단한 인프라를 구축했습니다.
<br /><br />
🌐   <a href="https://night-geography-507.notion.site/1-Linux-18bf283cbe204de5aa9f60d93f579867?pvs=4">자세한 서버 구축 과정 보러가기</a> 
<br /><br /></p>

<h4 id="q-ncloud-사용-중-특히-만족했던-점과-아쉬웠던-점은-무엇인가요">Q. Ncloud 사용 중 특히 만족했던 점과, 아쉬웠던 점은 무엇인가요?</h4>
<p>이전까지 AWS만 사용해봤기 때문에 아예 경험이 없던 Naver Cloud로 서버와 데이터베이스를 구성하는 게 조금 걱정이 됐었습니다. 그런 걱정에도 불구하고 공식 홈페이지에서 사용 가이드가 잘 작성되어 있어 생각보다 빠르게 서버와 데이터베이스를 생성할 수 있었고, 크레딧에 대해 남은 금액에 대해 이메일로 알림을 보내줘서 쉽게 확인할 수 있는 점이 아주 만족스러웠습니다.
그렇지만 Global Domain 적용을 위해 레퍼런스를 찾던 중 타사에 비해 레퍼런스가 적어서 시간이 조금 더 걸렸던 부분이 아주 약간은 아쉬웠습니다. ㅎㅎ
<br /><br /></p>

<h4 id="q-green-developers-프로그램-참여-소감">Q. Green Developers 프로그램 참여 소감</h4>
<p>AWS 프리티어처럼 제한된 용량 안에서 개발하는 것보다 진짜 실무를 경험할 수 있도록 다양한 Naver Cloud 서비스를 사용해 볼 수 있어서 정말 좋은 경험을 한 것 같습니다. 앞으로도 Naver Cloud에 대해 더 공부해 보고 싶은 계기가 되었습니다. 이런 프로그램 만들어주셔서 감사합니다!</p>]]></content><author><name>Dajeong Park</name></author><category term="blog" /><category term="NaverCloud" /><category term="NaverCloudPlatform" /><category term="프로젝트" /><category term="후기" /><summary type="html"><![CDATA[Q. 프로젝트를 소개해 주세요. 내 취향에 딱 맞는 아메리카노 카페 찾기 서비스 Americanote(아메리카노트)입니다. “카페 리뷰는 많은데 정작 커피 맛은 어떤지 모르겠어💦” “꼭 방문해서 먹어보고 커피 맛을 알아야 할까?” “내 취향에 딱 맞는 아메리카노를 먹고싶어!” 그래서 만들었습니다! Americanote는 카페를 방문하지 않고도 커피의 향, 강도, 산미를 알 수 있어요!]]></summary></entry><entry><title type="html">문자열 대치</title><link href="http://localhost:4000/wiki/2024/03/17/string-replacement.html" rel="alternate" type="text/html" title="문자열 대치" /><published>2024-03-17T00:00:00+09:00</published><updated>2024-03-17T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/03/17/string-replacement</id><content type="html" xml:base="http://localhost:4000/wiki/2024/03/17/string-replacement.html"><![CDATA[<h3 id="종류">종류</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">replace()</code></li>
  <li><code class="language-plaintext highlighter-rouge">replaceAll()</code></li>
  <li><code class="language-plaintext highlighter-rouge">replaceFirst()</code>
<br />
<br /></li>
</ol>

<h3 id="replacecharsequence-target-charsequence-replacement">replace(CharSequence target, CharSequence replacement)</h3>
<ul>
  <li>일치하는 문자열(target)을 새로운 문자열(replacement)로 치환한다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"가/나/다/라/마/바/사"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"/"</span><span class="o">,</span> <span class="s">","</span><span class="o">));</span> <span class="c1">// 가,나,다,라,마,바,사</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h3 id="replaceallstring-regex-string-replacement">replaceAll(String regex, String replacement)</h3>
<ul>
  <li>일치하는 정규 표현식(regex)을 새로운 문자열(replacement)로 <strong>전부</strong> 치환한다.
    <ul>
      <li>replace()와 유사하지만, <code class="language-plaintext highlighter-rouge">.</code>(온점) 같은 경우 정규 표현식으로 모든 문자를 의미하기 때문에 모든 문자열이 치환될 수 있다.
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"가.나.다.라.마.바.사"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str2</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"."</span><span class="o">,</span> <span class="s">","</span><span class="o">));</span> <span class="c1">// 가,나,다,라,마,바,사</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str2</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"."</span><span class="o">,</span> <span class="s">","</span><span class="o">));</span> <span class="c1">// ,,,,,,,,,,,,,</span>
</code></pre></div>        </div>
        <p><br /></p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="replace와-replaceall">replace()와 replaceAll()</h3>
<ul>
  <li>두 메소드는 일반 문자열 리터럴을 비교할 땐 실행 결과에 차이가 없다.</li>
  <li>하지만 replaceAll()은 문자열 대치에 정규식을 사용하여 조금 더 구체적인 검증이 가능하다.
<br />
<br /></li>
</ul>

<h3 id="replacefirststring-target-string-replacement">replaceFirst(String target, String replacement)</h3>
<ul>
  <li>첫번째로 일치하는 문자열(target)를 대체할 문자(replacement)로 치환한다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"가/나/다/라/마/바/사"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"/"</span><span class="o">,</span> <span class="s">","</span><span class="o">));</span> <span class="c1">// 가,나/다/라/마/바/사</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h3 id="실무-사용-예시">실무 사용 예시</h3>
<ul>
  <li>해시태그가 포함되어 있는 내용에 바꾸고 싶은 내용이 해시태그마다 다를 때 사용한다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">contents</span> <span class="o">=</span> <span class="n">reportMapper</span><span class="o">.</span><span class="na">findReportTemplate</span><span class="o">(</span><span class="mi">60001</span><span class="o">);</span>
<span class="n">contents</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"#"</span><span class="o">,</span> <span class="n">childName</span><span class="o">)</span>
              <span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"#"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">progress</span><span class="o">.</span><span class="na">getCount</span><span class="o">()))</span>
              <span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"#"</span><span class="o">,</span> <span class="n">progress</span><span class="o">.</span><span class="na">getPercent</span><span class="o">())</span>
              <span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"#"</span><span class="o">,</span> <span class="n">previous</span><span class="o">)</span>
              <span class="o">.</span><span class="na">replaceFirst</span><span class="o">(</span><span class="s">"#"</span><span class="o">,</span> <span class="n">average</span><span class="o">);</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li>https://coding-factory.tistory.com/128</li>
  <li>031724 추가
    <ul>
      <li>https://bada744.tistory.com/16</li>
    </ul>
  </li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="String" /><category term="Method" /><summary type="html"><![CDATA[종류 replace() replaceAll() replaceFirst()]]></summary></entry><entry><title type="html">Queue</title><link href="http://localhost:4000/wiki/2024/03/05/queue.html" rel="alternate" type="text/html" title="Queue" /><published>2024-03-05T00:00:00+09:00</published><updated>2024-03-05T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/03/05/queue</id><content type="html" xml:base="http://localhost:4000/wiki/2024/03/05/queue.html"><![CDATA[<h3 id="queue선형-큐">Queue(선형 큐)</h3>
<h4 id="특징">특징</h4>
<ul>
  <li>줄 서있는 것처럼 선입선출(FIFO) 형태의 자료구조</li>
  <li>정해진 한 곳(top)을 통해서 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에서 삽입 작업, 다른 쪽에서 삭제 작업이 양쪽으로 이루어진다.</li>
  <li>큐의 뒤(rear)에서만 삽입(enqueue)하고, 큐의 앞(front)에서는 삭제(dequeue)만 이루어진다.</li>
  <li>자바에서는 스택을 Stack 클래스로 구현하여 제공하지만, 큐는 Queue 인터페이스만 있고 별도의 클래스가 없다. 그래서 Queue 인터페이스를 구현한 클래스를 사용해야 한다.
<br /></li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>선형 큐에서 삽입/삭제를 반복하다 보면, rear가 맨 마지막 인덱스를 가리키고 앞에는 비어있을 수 있지만 이를 꽉 찼다고 인식한다. 데이터를 삭제할 때마다 한 칸 앞으로 이동시키는 것이 아니라 인덱스 단위로 큐의 연산을 진행하기 때문에 이러한 문제점이 있다. 이러한 단점을 보완하기 위해 Circular Queue(원형 큐)가 생겨났다.
<br /></li>
</ul>

<h4 id="메소드">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="n">자료형</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>
<p><strong><code class="language-plaintext highlighter-rouge">boolean add(E value)</code></strong></p>
<ul>
  <li>value 삽입 성공 시 true, 실패 시 Exception 발생</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean offer(E value)</code></strong></p>
<ul>
  <li>value 삽입 성공 시 true, 실패 시 false 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E remove(E value)</code></strong></p>
<ul>
  <li>value 삭제 성공 시 삭제된 value, 공백 큐라면 Exception(NoSuchElementException) 발생</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean remove(E value)</code></strong></p>
<ul>
  <li>해당 value가 존재하면 삭제 후 true, 존재하지 않으면 false 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E poll(E value)</code></strong></p>
<ul>
  <li>value 삭제 성공 시 삭제된 value, 공백 큐라면 null 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E element()</code></strong></p>
<ul>
  <li>head에 위치한 value를 리턴하거나, 공백 큐라면 Exception(NoSuchElementException) 발생</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">E peek()</code></strong></p>
<ul>
  <li>head에 위치한 value를 리턴하거나, 공백 큐라면 null 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">void clear()</code></strong></p>
<ul>
  <li>해당 큐를 초기화 함(공백 큐로 만듦)</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">int size()</code></strong></p>
<ul>
  <li>큐의 사이즈를 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean contains(E value)</code></strong></p>
<ul>
  <li>value가 존재하면 true, 없으면 false 리턴</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean isEmpty()</code></strong></p>
<ul>
  <li>공백 큐라면 true, 아니라면 false 리턴
<br /></li>
</ul>

<h4 id="활용">활용</h4>
<ul>
  <li>큐는 주로 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용한다.</li>
  <li>우선순위가 같은 작업 예약 (프린터의 인쇄 대기열)
    <ul>
      <li>작업 스케줄링</li>
    </ul>
  </li>
  <li>은행 업무</li>
  <li>콜센터 고객 대기 시간</li>
  <li>프로세스 관리</li>
  <li>너비 우선 탐색(BFS, Breadth-First Search) 구현</li>
  <li>캐시(Cache) 구현</li>
  <li>버퍼: 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역 (입출력 및 네트워크에서 사용)
<br />
<br /></li>
</ul>

<h3 id="circular-queue">Circular Queue</h3>
<h4 id="특징-1">특징</h4>
<ul>
  <li>1차원 배열을 사용하여 구현한다.</li>
  <li>초기 front와 rear는 맨 처음 인덱스에 위치한다.</li>
  <li>front와 rear를 회전시키기 위해서 모듈러(%) 연산을 사용한다.</li>
  <li><br /></li>
</ul>

<h4 id="주요-연산">주요 연산</h4>
<ul>
  <li><strong>enQueue</strong>: (rear + 1) % (배열의 크기)
    <ul>
      <li>만약 rear + 1이 front와 같으면 해당 큐는 꽉 찬 것이다.</li>
      <li>배열의 크기가 11인 배열의 index 10까지 모두 채우면, 다음 rear는 11이 아니라 0이 된다.</li>
    </ul>
  </li>
  <li><strong>deQueue</strong>: (front + 1) % (배열의 크기)</li>
  <li><strong>size</strong>: (배열의 크기 + rear - front) % (배열의 크기)
    <ul>
      <li>주의사항: rear == front(가득 찼을 때)도 마찬가지로 0이 된다.</li>
    </ul>
  </li>
  <li><strong>full</strong>: (rear + 1) % (배열의 크기) == front</li>
  <li><strong>empty</strong>: rear == front
<br />
<br /></li>
</ul>

<h3 id="priority-queue">Priority Queue</h3>
<h4 id="특징-2">특징</h4>
<ul>
  <li>Queue 인터페이스를 구현하였다.</li>
  <li>저장한 순서에 상관없이 우선순위(priority)가 높은 것부터 꺼낸다.</li>
  <li>null을 저장하면 NPE가 발생한다.</li>
  <li>배열을 사용하며, 각 요소를 힙이라는 자료구조의 형태로 저장한다. (JVM의 힙과 자료구조의 힙은 다르다!)</li>
  <li>지정하지 않으면 숫자가 작을 수록 우선순위가 높다.</li>
  <li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html">Priority Queue API</a>
<br /></li>
</ul>

<h4 id="구현-방법">구현 방법</h4>
<ul>
  <li>배열을 기반으로 구현하는 방법</li>
  <li>연결 리스트를 기반으로 구현하는 방법</li>
  <li>힙(heap)을 이용하는 방법</li>
  <li>배열이나 연결 리스트로 구현할 경우 간단하게 구현이 가능하지만, 데이터 삽입과 삭제 과정에서 데이터를 한 칸씩 당기거나 밀어야 하는 연산을 계속해야 한다. 또 삽입의 위치를 찾기 위해 배열에 저장된 모든 데이터와 우선순위를 비교해야 한다.</li>
  <li>연결 리스트의 경우, 삽입의 위치를 찾기 위해 첫번째 노트부터 싲가하여 마지막 노드에 저장된 데이터와 우선순위를 비교해야 할 수도 있다. (성능 저하) 그래서 일반적으로 힙을 이용하여 구현한다.
<br />
<br /></li>
</ul>

<h3 id="dequeue">Dequeue</h3>
<h4 id="특징-3">특징</h4>
<ul>
  <li>데이터의 추가와 삭제를 양쪽 끝에서 가능하게 하는 자료구조 (큐와 스택을 합친 형태로 생각할 수 있음)</li>
  <li>연속적인 메모리를 기반으로 하는 ‘시퀀스 컨테이너’이다. 따라서 임의 접근 반복자를 제공한다.</li>
  <li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html">Deque API</a>
<br /></li>
</ul>

<h4 id="유형">유형</h4>
<ul>
  <li><strong>scroll</strong>: 입력 제한 덱, 입력이 한쪽으로만 일어나도록 제한</li>
  <li><strong>self</strong>: 출력 제한 덱, 출력이 한쪽으로만 일어나도록 제한
<br /></li>
</ul>

<h4 id="활용-1">활용</h4>
<ul>
  <li>스케줄링: 스케줄링이 복잡해질 수록 스택과 덱보다 효율이 잘 나오는 경우가 있다.</li>
  <li>우선순위 조절: 한 방향으로만 삽입/삭제가 가능한 스택과 큐와 달리 양방향으로 삽입/삭제가 자유롭다.
<br />
<br /></li>
</ul>

<h3 id="stack과-queue의-차이점">Stack과 Queue의 차이점</h3>
<ul>
  <li>아이템을 삭제할 때 가장 큰 차이점이 있다.</li>
  <li>스택은 가장 마지막에 추가된 item을 삭제하고, 큐는 가장 처음 들어와있던 item을 삭제한다.</li>
  <li>스택과 큐 모두 Peek을 사용할 수 있다. Peak 연산은 자료구조의 변화를 주지 않고, pop이나 dequeue를 할 때 리턴되는 item을 리턴할 수 있다.
<br />
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li>https://devuna.tistory.com/22</li>
  <li>https://kwin0825.tistory.com/157</li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="DataStructure" /><category term="Queue" /><summary type="html"><![CDATA[Queue(선형 큐) 특징 줄 서있는 것처럼 선입선출(FIFO) 형태의 자료구조 정해진 한 곳(top)을 통해서 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에서 삽입 작업, 다른 쪽에서 삭제 작업이 양쪽으로 이루어진다. 큐의 뒤(rear)에서만 삽입(enqueue)하고, 큐의 앞(front)에서는 삭제(dequeue)만 이루어진다. 자바에서는 스택을 Stack 클래스로 구현하여 제공하지만, 큐는 Queue 인터페이스만 있고 별도의 클래스가 없다. 그래서 Queue 인터페이스를 구현한 클래스를 사용해야 한다.]]></summary></entry><entry><title type="html">프로그래머스 - 같은 숫자는 싫어 풀이</title><link href="http://localhost:4000/wiki/2024/02/29/programmers-12906.html" rel="alternate" type="text/html" title="프로그래머스 - 같은 숫자는 싫어 풀이" /><published>2024-02-29T00:00:00+09:00</published><updated>2024-02-29T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/02/29/programmers-12906</id><content type="html" xml:base="http://localhost:4000/wiki/2024/02/29/programmers-12906.html"><![CDATA[<h3 id="문제">문제</h3>
<p><img src="https://dajeongdev.github.io/assets/images/posts/programmers-12906.png" /></p>
<ul>
  <li>연속적으로 나타나는 숫자, 즉 앞의 숫자와 겹치면 제거하기 때문에 Stack을 사용해서 풀이를 해보려고 한다.</li>
  <li>https://school.programmers.co.kr/learn/courses/30/lessons/12906
<br /> <br />
<br /></li>
</ul>

<h3 id="풀이">풀이</h3>
<p><strong>첫번째</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">firstSolution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
	<span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">answer</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
			<span class="k">continue</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="n">answer</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>이렇게 했더니 33.7점 나옴…</li>
  <li><code class="language-plaintext highlighter-rouge">arr.length - 1</code> 부분이 오답 → <code class="language-plaintext highlighter-rouge">arr.length</code>라고 해야 배열 끝까지 확인함</li>
  <li>리턴값이 틀린 줄 알았는데 저 부분은 맞음
<br /></li>
</ul>

<p><strong>두번째</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">secondSolution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">nun</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">answer</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">answer</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="n">answer</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>한 줄이라도 더 줄이기 위해 스택에 배열의 첫번째 값을 넣는 코드(<code class="language-plaintext highlighter-rouge">answer.add(arr[0]</code>)를 제거하고, if문에 <code class="language-plaintext highlighter-rouge">answer.isEmpty()</code>로 바꿈</li>
  <li>따라서 index를 쓸 필요가 없기 때문에 향상된 for문으로 조금 더 가독성 있게 작성
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li>다른 사람들 풀이를 보니 Stack을 사용하지 않은 사람도 많았다. Stack 클래스를 사용하는 것도 좋지만, 다른 클래스를 사용한 코드들도 많이 참고해서 이해력을 높여봐야겠다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">otherSolution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span> <span class="c1">// 이전값 저장</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="n">prev</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">answer</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="DataStructure" /><category term="Programmers" /><summary type="html"><![CDATA[문제 연속적으로 나타나는 숫자, 즉 앞의 숫자와 겹치면 제거하기 때문에 Stack을 사용해서 풀이를 해보려고 한다. https://school.programmers.co.kr/learn/courses/30/lessons/12906]]></summary></entry><entry><title type="html">String 배열 -&amp;gt; String</title><link href="http://localhost:4000/wiki/2024/02/26/string-array-to-string.html" rel="alternate" type="text/html" title="String 배열 -&amp;gt; String" /><published>2024-02-26T00:00:00+09:00</published><updated>2024-02-26T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/02/26/string-array-to-string</id><content type="html" xml:base="http://localhost:4000/wiki/2024/02/26/string-array-to-string.html"><![CDATA[<h3 id="배경">배경</h3>
<ul>
  <li>코딩테스트 문제를 풀면서 String 배열을 String으로 변환하는 작업이 자주 나와서 기록해두려고 한다. <br />
<br /></li>
</ul>

<h3 id="1-stringjoincharsequence-delimiter-charsequence-elements">1. String.join(CharSequence delimiter, CharSequence… elements)</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">join()</code> 메서드는 delimiter(구분자)를 사용하여 elements(대상 배열)을 문자열을 리턴할 수 있다.</li>
  <li>String.join() 메서드는 Java 1.8 이상부터 사용 가능
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">strArr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"hello"</span><span class="o">,</span> <span class="s">"java"</span><span class="o">};</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">","</span><span class="o">,</span> <span class="n">strArr</span><span class="o">));</span>
<span class="c1">// 결과 : hello,java</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h3 id="2-arraystostringobject-a">2. Arrays.toString(Object[] a)</h3>
<ul>
  <li>Arrays 클래스의 <code class="language-plaintext highlighter-rouge">toString()</code> 메서드를 사용하여 배열 모양의 문자열을 리턴할 수 있다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">strArr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"hello"</span><span class="o">,</span> <span class="s">"java"</span><span class="o">};</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">strArr</span><span class="o">));</span>
<span class="c1">// 결과 : [hello, java]</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h3 id="3-stream---collectorsjoining">3. Stream - Collectors.joining()</h3>
<ul>
  <li>Stream의 <code class="language-plaintext highlighter-rouge">Collectors.joining()</code> 메서드를 사용하여 문자열을 리턴할 수 있다.</li>
  <li>Stream은 Java 1.8 이상부터 사용 가능
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">strArr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"hello"</span><span class="o">,</span> <span class="s">"java"</span><span class="o">};</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">strArr</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">()));</span>
<span class="c1">// 결과 : hellojava</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h3 id="4-stringbuilderappendstring-str">4. StringBuilder.append(String str)</h3>
<ul>
  <li>가장 기본적인 방법 중에는 StringBuilder를 생성하여 <code class="language-plaintext highlighter-rouge">append()</code> 메서드를 사용하여 문자열을 리턴할 수 있다.</li>
  <li>빠르지만 for문을 사용하기 때문에 코드가 조금 길어진다는 단점이 있다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">strArr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"hello"</span><span class="o">,</span> <span class="s">"java"</span><span class="o">};</span>
<span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strArr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
  <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">strArr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sb</span><span class="o">);</span>
<span class="c1">// 결과 : hellojava</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h3 id="5-apache-commons-lang-3--라이브러리">5. Apache Commons Lang 3  라이브러리</h3>
<ul>
  <li><a href="https://commons.apache.org/proper/commons-lang">Apache Commons Lang 3</a> 라이브러리는 Java의 유틸리티 클래스 패키지로, 문자열, 배열, 숫자 등 매우 다양하고 편리한 기능을 제공한다.</li>
  <li>그 중 StringUtils 클래스의 <code class="language-plaintext highlighter-rouge">join()</code> 메서드를 사용하여 문자열 배열을 문자열로 리턴할 수 있다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">strArr</span> <span class="o">=</span> <span class="o">{</span><span class="s">"hello"</span><span class="o">,</span> <span class="s">"java"</span><span class="o">};</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">strArr</span><span class="o">,</span> <span class="s">","</span><span class="o">));</span>
<span class="c1">// 결과 : hello,java</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="String" /><summary type="html"><![CDATA[배경 코딩테스트 문제를 풀면서 String 배열을 String으로 변환하는 작업이 자주 나와서 기록해두려고 한다.]]></summary></entry><entry><title type="html">SpringBoot 3.2부터 @PathVariable 이름 미지정 시 에러</title><link href="http://localhost:4000/wiki/2024/01/17/pathvariable-name-missing.html" rel="alternate" type="text/html" title="SpringBoot 3.2부터 @PathVariable 이름 미지정 시 에러" /><published>2024-01-17T00:00:00+09:00</published><updated>2024-01-17T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/01/17/pathvariable-name-missing</id><content type="html" xml:base="http://localhost:4000/wiki/2024/01/17/pathvariable-name-missing.html"><![CDATA[<h3 id="배경">배경</h3>
<ul>
  <li>팀원이 작업한 코드를 pull 받아서 실행시켰는데 아래처럼 에러가 발생했다. 그런데 팀원이 올리기 전에 실행시켰을 땐 발생하지 않았던 에러가 왜 내 로컬에서는 발생했을까?
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span><span class="o">:</span> <span class="nc">Name</span> <span class="k">for</span> <span class="n">argument</span> <span class="n">of</span> <span class="n">type</span> <span class="o">[</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">]</span> <span class="n">not</span> <span class="n">specified</span><span class="o">,</span> <span class="n">and</span> <span class="n">parameter</span> <span class="n">name</span> <span class="n">information</span> <span class="n">not</span> <span class="n">found</span> <span class="n">in</span> <span class="kd">class</span> <span class="nc">file</span> <span class="n">either</span><span class="o">.</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h3 id="원인">원인</h3>
<ul>
  <li>Spring Boot 3.2 이전에는 경로의 변수명와 @PathVariable의 변수명이 같을 때 생략할 수 있었다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/{id}"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">testMethod</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{...}</span>
</code></pre></div>    </div>
    <p><img src="https://dajeongdev.github.io/assets/images/posts/parameter-name-retention.png" /></p>
  </li>
  <li>Spring Boot 3.2 전에는 바이트코드를 파싱해서 매개변수 이름을 추론하려고 시도했지만 3.2 부터는 이 부분이 사라져서 @PathVariable을 포함한 몇몇 어노테이션(@RequestParam, @Autowired, @ConfigurationProperties)에서 매개변수 인식 문제가 발생하고 있다.</li>
  <li><a href="https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-6.x#parameter-name-retention">공식 문서 참고</a>
<br /></li>
</ul>

<h3 id="해결방법">해결방법</h3>
<ol>
  <li><strong>어노테이션에 이름을 생략하지 않고 항상 적는다.</strong>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/{id}"</span><span class="o">)</span>
 <span class="kd">public</span> <span class="nc">String</span> <span class="nf">testMethod</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{...}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>컴파일 시점에 -parameters 옵션을 적용한다.</strong>
    <ol>
      <li>IntelliJ IDEA에서 File -&gt; Settings를 연다. (Mac은 IntelliJ IDEA -&gt; Settings)</li>
      <li>Build, Execution, Deployment → Compiler → Java Compiler로 이동한다.</li>
      <li>Additional command line parameters라는 항목에 다음을 추가한다. (<code class="language-plaintext highlighter-rouge">-parameters</code>)</li>
      <li>out 폴더를 삭제하고 다시 실행한다. <strong>꼭 out 폴더를 삭제해야 다시 컴파일이 일어난다.</strong></li>
    </ol>
  </li>
  <li><strong>Gradle로 빌드하고 실행한다.</strong>
    <ul>
      <li>참고로 이 문제는 Build, Execution, Deployment -&gt; Build Tools -&gt; Gradle에서 Build and run using를 IntelliJ IDEA로 선택한 경우에만 발생한다.</li>
      <li>Gradle로 선택한 경우에는 Gradle이 컴파일 시점에 해당 옵션을 자동으로 적용해준다.
<br /></li>
    </ul>
  </li>
</ol>

<h4 id="나의-의견">나의 의견</h4>
<ul>
  <li>결국 김영한님 강의를 많이 봤던 나는 프로젝트 초반에 Build and run using 설정을 IntelliJ로 바꾸고 사용 중이었고, 팀원은 Gradle로 빌드 및 실행을 하고 있어서 발생한 문제였다.</li>
  <li>나 또한 설정을 바꿨지만, Spring Boot 3.2부터 이름을 붙이지 않으면 에러가 발생할 수도 있는 부분이기 때문에 우리 팀은 해결방법 1번을 선택하여 이름을 일관적이게 붙여주기로 결정했다.
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li><a href="https://www.inflearn.com/questions/1088283/pathvariable-%EB%B3%80%EC%88%98%EB%AA%85-%EA%B0%99%EC%9D%84%EB%95%8C-%EC%83%9D%EB%9E%B5%EC%8B%9C-%EC%98%A4%EB%A5%98-%EB%B9%8C%EB%93%9C-%EC%84%A4%EC%A0%95%EC%9D%84-gradle%EB%A1%9C-%ED%95%98%EB%A9%B4-%ED%95%B4%EA%B2%B0%EB%90%98%EB%8A%94-%EA%B2%83-%EA%B0%99%EC%8A%B5%EB%8B%88%EB%8B%A4">https://www.inflearn.com/questions/1088283</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Spring" /><category term="SpringBoot" /><summary type="html"><![CDATA[배경 팀원이 작업한 코드를 pull 받아서 실행시켰는데 아래처럼 에러가 발생했다. 그런데 팀원이 올리기 전에 실행시켰을 땐 발생하지 않았던 에러가 왜 내 로컬에서는 발생했을까? java.lang.IllegalArgumentException: Name for argument of type [java.lang.String] not specified, and parameter name information not found in class file either.]]></summary></entry><entry><title type="html">update 시 @CreatedDate를 붙인 컬럼에 null이 들어가는 문제와 해결 방법</title><link href="http://localhost:4000/wiki/2024/01/12/jpa-created-date-column-null.html" rel="alternate" type="text/html" title="update 시 @CreatedDate를 붙인 컬럼에 null이 들어가는 문제와 해결 방법" /><published>2024-01-12T00:00:00+09:00</published><updated>2024-01-12T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/01/12/jpa-created-date-column-null</id><content type="html" xml:base="http://localhost:4000/wiki/2024/01/12/jpa-created-date-column-null.html"><![CDATA[<h3 id="배경">배경</h3>
<ul>
  <li>update문의 결과를 확인하는데 생성일 컬럼이 null로 update 되는 문제를 발견했다. <br />
<br /></li>
</ul>

<h3 id="원인">원인</h3>
<ul>
  <li>정확히는 생성일 컬럼에 이름을 설정하기 위해 붙인 @Column 어노테이션의 옵션 중 하나인 updatable의 기본값이 true라서 값을 설정해주지 않은 생성일 컬럼에 null이 update 된 것이다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Target</span><span class="o">({</span><span class="no">METHOD</span><span class="o">,</span> <span class="no">FIELD</span><span class="o">})</span> 
<span class="nd">@Retention</span><span class="o">(</span><span class="no">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Column</span> <span class="o">{</span>
	    <span class="cm">/**
	     * (Optional) Whether the column is included in SQL UPDATE 
	     * statements generated by the persistence provider.
	     */</span>
	    <span class="kt">boolean</span> <span class="nf">updatable</span><span class="o">()</span> <span class="k">default</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="해결-방법">해결 방법</h3>
<ul>
  <li>그래서 @Column 어노테이션의 updatable 옵션을 false로 지정해주어야 한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@CreatedDate</span>
<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"created_date_time"</span><span class="o">,</span> <span class="o">**</span><span class="n">updatable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">**)</span>
<span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">createdDateTime</span><span class="o">;</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="참고">참고</h4>
<ul>
  <li>https://wakestand.tistory.com/935</li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Spring" /><category term="JPA" /><summary type="html"><![CDATA[배경 update문의 결과를 확인하는데 생성일 컬럼이 null로 update 되는 문제를 발견했다.]]></summary></entry><entry><title type="html">hibernate6 custom function(MySQL Dialect)</title><link href="http://localhost:4000/wiki/2023/12/30/hibernate6-custom-function.html" rel="alternate" type="text/html" title="hibernate6 custom function(MySQL Dialect)" /><published>2023-12-30T00:00:00+09:00</published><updated>2023-12-30T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2023/12/30/hibernate6-custom-function</id><content type="html" xml:base="http://localhost:4000/wiki/2023/12/30/hibernate6-custom-function.html"><![CDATA[<h3 id="배경">배경</h3>
<p>현재 프로젝트에서 QueryDSL을 사용 중인데 여기에 집계함수를 사용하고 싶어서 사용자 함수 추가를 위해 서치 후 적용해보려고 했다. 그런데 이게 웬일.. Spring boot 3점대에서는 hibernate 6.1을 기본으로 사용하고 있어서 당장 올해 3월까지 올라온 블로그 글의 코드도 적용되지 않았다.. 그래서 한시간을 고생해서 적용해보고 고치고 하다가 김영한님 JPA 강의의 커뮤니티에 어떤 친절한 분이 해결방안을 올려주셨다.. 정말 천사,,</p>

<p><img src="https://dajeongdev.github.io/assets/images/posts/spring-boot-3.2-hibernate-version.png" />
<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M4-Release-Notes">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M4-Release-Notes</a>
<br />
<br /></p>

<h3 id="해결">해결</h3>
<ol>
  <li>FunctionContributor의 구현체를 만들어준다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomFunctionContributor</span> <span class="kd">implements</span> <span class="nc">FunctionContributor</span> <span class="o">{</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">contributeFunctions</span><span class="o">(</span><span class="nc">FunctionContributions</span> <span class="n">functionContributions</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">functionContributions</span><span class="o">.</span><span class="na">getFunctionRegistry</span><span class="o">()</span>
            <span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="s">"group_concat"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">StandardSQLFunction</span><span class="o">(</span><span class="s">"group_concat"</span><span class="o">,</span> <span class="nc">StandardBasicTypes</span><span class="o">.</span><span class="na">STRING</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>src/main/resources 하위에 META-INF/services/org.hibernate.boot.model.FunctionContributor 파일을 생성한다.</li>
  <li>
    <p>해당 파일에 1번의 구현체를 등록한다.</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">패키지명.구현체</code> 이름의 형태로 등록</li>
      <li>com.example.com.config.~Contributor
      -   yml 파일의 dialect 변경은 필요없음
<br /> <br />
<br /></li>
    </ul>
  </li>
</ol>

<h3 id="시도">시도</h3>
<ul>
  <li><a href="https://discourse.hibernate.org/t/migrate-hibernate-5-to-6-with-spring-boot-2-7-x-to-3/7787/2">https://discourse.hibernate.org/t/migrate-hibernate-5-to-6-with-spring-boot-2-7-x-to-3/7787/2</a></li>
  <li><a href="https://discourse.hibernate.org/t/migration-of-dialect-to-hibernate-6/6956/16">https://discourse.hibernate.org/t/migration-of-dialect-to-hibernate-6/6956/16</a></li>
  <li><a href="https://thisiswoo.github.io/development/using-jpa-querydsl-groupconcat-func.html">https://thisiswoo.github.io/development/using-jpa-querydsl-groupconcat-func.html</a>
<br />
<br /></li>
</ul>

<p><strong>참고</strong></p>
<ul>
  <li><a href="https://www.inflearn.com/questions/1096265/hibernate-6-custom-%ED%95%A8%EC%88%98-%EB%93%B1%EB%A1%9D-%EB%B0%A9%EB%B2%95-%EA%B3%B5%EC%9C%A0"></a><a href="https://www.inflearn.com/questions/1096265/hibernate-6-custom-%ED%95%A8%EC%88%98-%EB%93%B1%EB%A1%9D-%EB%B0%A9%EB%B2%95-%EA%B3%B5%EC%9C%A0">https://www.inflearn.com/questions/1096265/hibernate-6-custom-함수-등록-방법-공유</a></li>
  <li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M4-Release-Notes">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M4-Release-Notes</a></li>
  <li><a href="https://velog.io/@ttomy/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-dialectmatch-against%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0"></a><a href="https://velog.io/@ttomy/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-dialectmatch-against%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">https://velog.io/@ttomy/사용자-정의-dialectmatch-against사용하기</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Hibernate6" /><category term="MySQLDialect" /><category term="SpringBoot3" /><category term="QueryDSL" /><category term="JPQL" /><summary type="html"><![CDATA[배경 현재 프로젝트에서 QueryDSL을 사용 중인데 여기에 집계함수를 사용하고 싶어서 사용자 함수 추가를 위해 서치 후 적용해보려고 했다. 그런데 이게 웬일.. Spring boot 3점대에서는 hibernate 6.1을 기본으로 사용하고 있어서 당장 올해 3월까지 올라온 블로그 글의 코드도 적용되지 않았다.. 그래서 한시간을 고생해서 적용해보고 고치고 하다가 김영한님 JPA 강의의 커뮤니티에 어떤 친절한 분이 해결방안을 올려주셨다.. 정말 천사,,]]></summary></entry></feed>