<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2024-05-10T14:53:34+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Every Single Day</title><subtitle></subtitle><author><name>Dajeong Park</name></author><entry><title type="html">독서 관리 서비스의 Admin 개발 회고</title><link href="http://localhost:4000/blog/2024/05/10/book-service-admin-review.html" rel="alternate" type="text/html" title="독서 관리 서비스의 Admin 개발 회고" /><published>2024-05-10T00:00:00+09:00</published><updated>2024-05-10T00:00:00+09:00</updated><id>http://localhost:4000/blog/2024/05/10/book-service-admin-review</id><content type="html" xml:base="http://localhost:4000/blog/2024/05/10/book-service-admin-review.html"><![CDATA[<p>홈페이지 마이그레이션, 도서 단행본 API 구현 업무를 마치고 나니 협력사와 아이가 도서를 읽고 독후감을 쓰면 첨삭해주는 서비스를 만들게 됐는데, 당시 일손이 부족해서 내가 관리자를 통으로 담당하게 되었다.
<br />
<br /></p>

<p>사수분들께서 바빠서 잘 봐줄 수 없을 것 같다고 하셔서 (ㅎㅎ) 기획서를 받기 전부터 조금 긴장했던 것 같다.
기초 설정은 차장님께서 해주셔서 Spring Boot 2.4.1 버전에 Maven을 사용한 프로젝트를 생성해주셨고, 홈페이지 마이그레이션 때처럼 Thymeleaf를 사용하기로 했는데, 마이그레이션 때 사용해봐서 걱정은 조금 덜었었다.
<br />
<br /></p>

<p>관리자 페이지답게 엑셀 다운로드부터 Push(FCM) 발송, 첨삭 수동 매칭, 첨삭 교사의 라이센스 확인, 관리자 권한 설정 그리고 사용자 통계까지 정말 다양한 기능을 8월 중순부터 1월 초까지 작업했으니 약 5개월동안 정말 열심히 했었다. 그래서 힘들다기보다는 해보지 못했던 기능을 만들어봐서 정말 재미있게 개발했다.
<br />
<br /></p>

<p>이번 프로젝트에서는 기획서가 있었는데, 미리 주신 덕분에 보면서 “내가 관리자라면 검색할 때 이 조건을 불편하지 않을까?”라고 관리자의 입장에서 생각해보면서 추가하거나 삭제해도 괜찮을 것 같은 기능들을 정리해서 운영팀 과장님과 상의하면서 작업했더니 확실히 완성도가 올라간다는 느낌이 들었다. 이때부터 기획서나 피그마를 잘 분석해서 의사소통하는 게 팀워크에 좋은 영향을 끼친다고 생각했다.
<br />
<br /></p>

<h4 id="프론트단">프론트단</h4>
<p>관리자 페이지의 프론트 부분을 제대로 작업해본 건 처음이었는데, 디자인에 너무 신경쓰지 않아도 된다고 하셨지만 그래도 어느정도는 깔끔하게 보이고 싶었다.</p>

<p>아무래도 관리자 페이지는 비슷한 페이지들이 많다보니 모달이나 글자수 카운팅, 페이징, 이미지 탭 같은 부분을 공통적으로 사용하는 게 좋을 것 같다고 판단해서 그런 기능들은 컴포넌트화 시켜서 사용하기 시작했다.</p>

<p>그리고 개발 트렌드에 맞게 jQuery 대신 Javascript만 사용하고 싶다는 목표도 세웠기 때문에 작업 중에 드림코딩이나 노마드코더 같은 Javascript 강의를 들어보니 Java랑 조금 다른 부분들이 재미있게 느껴졌다.
<br />
<br /></p>

<h4 id="백단">백단</h4>
<p>백단 작업도 이전 프로젝트보다 더 발전하고 싶다는 생각이 들었다. 김영한님의 Spring 강의를 들으면서 @Autowired 대신 생성자 주입을 위해 @RequiredArgument 사용하는 것처럼 더 나은 코드를 위해 필요한 부분들을 체크해서 실무에 적용해보기도 했다.</p>

<p>백단 부분은 계속 MyBatis를 사용했기 때문에 입사 전에 했던 팀프로젝트 때랑 많이 다르지 않아서 편했지만, 통계나 여러 테이블을 조인하는 과정이 어려웠기 때문에 대리님께 질문도 드리고, 개인적으로도 검색을 통해 많이 배웠다. 최근에는 JPA만 써서 MyBatis도 한 번 제대로 정리해봐야겠다..</p>

<p>그리고 이때 처음으로 프로젝트를 서버에 배포하는 것도 알려주셔서 해봤는데 생각보다 어려워서 공부를 많이 해야겠다고 생각했다. 실서버가 2개라는 것도 차장님이 말씀을 안 해주셔서 막바지에 알게 된 해프닝도 있었다. ㅋㅋ
<br />
<br /></p>

<h4 id="소감">소감</h4>
<p>중간중간 운영팀 과장님과 대리님께 피드백도 받아가면서 프로젝트를 마무리했더니 의사소통도 잘하고 손이 빠르다는 평을 들었다. 새로운 기능도 많이 개발해보고, 프론트단도 처음이지만 이리저리 공부하면서 작업한 부분도 정말 뿌듯했다. 이 프로젝트를 통해서 팀원들과의 의사소통과 사용자 입장에서 개발하는 것의 중요성을 뼈저리게 깨달았다.</p>

<p>그리고 공부해서 바로 실무에 적용해보는 게 정말 재미있기도 했는데, 실제로 다음 프로젝트부터는 VO를 보호하기 위해 DTO와 Builder 패턴을 사용하는 등 김영한님의 강의가 정말 하나하나 피가 되고 살이 되어서 모든 강의를 다 수강해서 열심히 공부하기도 했다.</p>]]></content><author><name>Dajeong Park</name></author><category term="blog" /><category term="Project" /><category term="Admin" /><category term="Review" /><summary type="html"><![CDATA[홈페이지 마이그레이션, 도서 단행본 API 구현 업무를 마치고 나니 협력사와 아이가 도서를 읽고 독후감을 쓰면 첨삭해주는 서비스를 만들게 됐는데, 당시 일손이 부족해서 내가 관리자를 통으로 담당하게 되었다.]]></summary></entry><entry><title type="html">도서 등록 API 속도 개선 회고</title><link href="http://localhost:4000/blog/2024/05/10/book-insert-api-speed-improvement-review.html" rel="alternate" type="text/html" title="도서 등록 API 속도 개선 회고" /><published>2024-05-10T00:00:00+09:00</published><updated>2024-05-10T00:00:00+09:00</updated><id>http://localhost:4000/blog/2024/05/10/book-insert-api-speed-improvement-review</id><content type="html" xml:base="http://localhost:4000/blog/2024/05/10/book-insert-api-speed-improvement-review.html"><![CDATA[<p>홈페이지 마이그레이션 이후 새로운 업무를 받았다.</p>

<p>당시 자사 서비스인 도서 플랫폼에서는 사용자로부터 도서 등록 문의를 받아 등록해줬었다.</p>

<p>문의한 도서가 ‘전집’일 때는 운영팀에서 도서를 검색해서 개발팀에게 전달해 데이터베이스에 등록하는 과정을 거쳤지만,<br />
‘단행본’일 때는 운영팀에서 관리자 페이지에서 직접 등록하기도 했다.<br />
하지만 점점 요청이 많아지기도 해서 내가 ‘단행본’ 등록하는 API를 개발하게 되었다.
<br />
<br /></p>

<p>기존 전집 등록 API를 이용하면 금방 만들 수 있겠다고 생각했지만, 도서 플랫폼의 백단 프로젝트가 거대한 레거시 프로젝트라는 한 가지 복병이 있었다.</p>

<p>레거시 프로젝트는 JPA로 구성되어 있었지만, JPA의 장점을 하나도 사용하지 않는 데다 특정 메소드만 사용하고 있었고,<br />
사용하고 있는 특정 메소드 또한 방대한 중복 및 로깅 코드에 클래스와 메소드 이름이 중구난방에 의미도 불분명했다.<br />
게다가 데이터베이스도 테이블이 엄청나게 얽혀 있어 함부로 수정할 수 없는 상태였다.
<br />
<br /></p>

<p>이런 상태에서 그대로 단행본 API만 만들 수도 있었지만, 왠지 마음이 찝찝해서 기존 전집 등록 API부터 개선해보기로 했다. 그리고 이때 속도를 비교해보면 좋을 것 같아서 <code class="language-plaintext highlighter-rouge">System.currentTimeMillis</code> 메소드를 사용해서 이전 코드의 속도를 측정해보니 50권의 전집을 등록할 때 5.56초가 걸렸다.
<br />
<br /></p>

<p>일단 이리갔다 저리갔다 코드가 너무 보기 불편했기 때문에 클래스와 메서드부터 연관성에 따라서 재배치하거나 분리했다.<br />
그리고 불명확하게 작성되어 있던 메소드 이름도 가독성 있는 이름으로 바꿨다.<br />
마지막으로는 수많은 로깅 및 주석 코드를 정리했고, 중간중간 중복 코드도 찾아내어 삭제했다.</p>

<p>이후 코드 속도를 다시 측정해보니 같은 전집을 등록할 때 3.27초로 속도가 개선되었다.
<br />
<br /></p>

<p>이후 단행본 API를 구현하는 건 정말 간단했다.<br />
원래는 같은 API를 쓰고 싶었지만, 운영팀에서 주시는 전집과 단행본의 엑셀 컬럼이 달라서 다른 API로 분리를 한 다음<br />
엑셀을 읽어들이는 부분만 다르게 설정하고, 내부 로직은 동일한 메소드를 사용하도록 조정했다.
<br />
<br /></p>

<h4 id="소감">소감</h4>
<p>단행본 API를 구현하라는 업무에서 사실상 전집 API를 개선하는 데 더 시간을 많이 보냈지만 개인적으로 정말 뿌듯한 업무였다. ㅎㅎ 주니어 때 해보기 힘든 속도도 개선도 해보고, 데이터에 영향이 가지 않도록 고민하는 과정들이 개발자라는 직업에 대해 깊이 있게 생각하게 만들어 준 것 같다~!</p>]]></content><author><name>Dajeong Park</name></author><category term="blog" /><category term="Project" /><category term="Review" /><summary type="html"><![CDATA[홈페이지 마이그레이션 이후 새로운 업무를 받았다.]]></summary></entry><entry><title type="html">홈페이지 마이그레이션 회고</title><link href="http://localhost:4000/blog/2024/05/09/hompage-migration-review.html" rel="alternate" type="text/html" title="홈페이지 마이그레이션 회고" /><published>2024-05-09T00:00:00+09:00</published><updated>2024-05-09T00:00:00+09:00</updated><id>http://localhost:4000/blog/2024/05/09/hompage-migration-review</id><content type="html" xml:base="http://localhost:4000/blog/2024/05/09/hompage-migration-review.html"><![CDATA[<p>포트폴리오를 작성하다보니 생각보다 예전에 했던 프로젝트들이 회고해볼 만한 게 많아서 한 번 되짚어보려고 한다.
<br />
<br /></p>

<p>입사 당시 첫 주는 거의 일이 없어서 심심했었는데, 2주차에는 드디어 첫 업무를 받았다.
<br /></p>

<p>Spring 4.3.3, Maven, JSP로 구성되어 있던 프로젝트를 Spring Boot, Gradle, Thymeleaf로 마이그레이션 하는 업무였는데, 마이그레이션 자체도 처음이고 Spring Boot와 Thymeleaf도 처음 써보는 거라 걱정반 기대반으로 조사부터 했었다.
<br /></p>

<p>다행스럽게도 마이그레이션에 대한 레퍼런스가 많아서 찬찬히 읽어보고 시작했다.
<br /></p>

<p>일단 Spring 4점대가 이미 개발 지원이 종료된 상태였고, 불필요한 중복 코드나 주석도 많아서 함께 리팩토링하기로 했다. 그리고 한꺼번에 바꾸게 되면 에러날 확률이 높다고 해서 하나씩 바꾸기로 했다.
<br />
<br /></p>

<h4 id="1-spring--springboot">1. Spring → SpringBoot</h4>
<p>spring boot 의존성도 추가하고, xml 파일들을 yml 혹은 config 파일로 분리했다.</p>

<p>xml 파일이 적지 않아서 yml 문법에 맞게 옮기는 데 시간이 조금 걸렸고, java config 파일은 웬만하면 만들고 싶지 않아서 yml 문법으로 가능한 건 다 yml로 처리했었다.
<br /></p>

<h4 id="2-maven--gradle">2. Maven → Gradle</h4>
<p>maven에서 gradle로 변경하는 건 생각보다 간단했는데, 일단 gradle을 설치하고 환경변수를 설정한 후 프로젝트 내에서 reload gradle project를 해주면 된다.</p>

<p>그런데 빌드하면서 에러가 발생했는데 lombok 부분을 annotationProcessor로 변경해주니 금방 해결되었다.
<br /></p>

<h4 id="3-jsp--thymeleaf">3. JSP → Thymeleaf</h4>
<p>당연하지만 3가지 순서 중에 가장 오래 걸린 부분이다.
<br /></p>

<p>사실 이 부분은 내가 하고 싶어서 한 부분인데, JSP를 지양하는 문화로 가기도 했고 Spring Boot를 사용할 때 Thyemelaf를 권고한다고 해서 써보고 싶었다. Thymeleaf는 성능면에서 JSP보다 조금 느리지만, Jar 파일로 빌드할 수 있다. 그리고 무엇보다 HTML과 자바 코드가 섞이지 않아도 되는 점이 가장 마음에 들었다.
<br /></p>

<p>Thymeleaf는 JSP와 인식되는 폴더 자체가 다르기 때문에 폴더 구조부터 수정한 뒤 jsp 파일을 html 파일로 변경했다.</p>

<p>이후부터는 Thymeleaf 문법에 맞추는 수작업이었는데, Thymeleaf 설정에서 cache를 false로 설정해주면 브라우저에서 새로고침만으로도 바로 변경사항을 반영해볼 수 있어서 정말 편리했다.
<br />
<br /></p>

<h4 id="ps-css하">P.S. CSS..하..</h4>
<p>진짜 여러모로 CSS 덕분에 아주 눈물이 날 뻔 했다. Thymeleaf까지만 해도 재미있었는데, 확신의 백엔드인건지 CSS 부분 수정하는 데 더 오래 걸려서 아주 미치는 줄 알았다.
이미지인 줄 알았는데 하드 코딩된 거라는 것도… ㅋㅋㅋㅋ 그래도 실무에서 이런 경험 해보는 것도 나쁘지 않았다.. 이후 관리자 개발할 때도 많이 도움되기도 했고!
<br />
<br /></p>

<h4 id="소감">소감</h4>
<p>사실 지금 생각해보면 아주 간단한 프로젝트였고, 모르는 게 있으면 질문을 정리해서 대리님께 물어봤기 때문에 금방 해낼 수 있었다.
첫 업무를 생각보다 빠르게 끝내서 기분 좋기도 했고(당연하지만 지금 하면 더 잘할 수 있을텐데),
회사에서도 뭔가 시켜도 되겠다 싶으셨는지 이후에 업무를 차근차근 받아서 진행하는 계기가 됐었다.
<br /></p>

<p>지금 생각해보면 일하느라 바빠서 말도 많이 안했던 것 같은데 ㅋㅋ 조용히 열심히 하는 직원으로 생각해주셨으려나~</p>]]></content><author><name>Dajeong Park</name></author><category term="blog" /><category term="Java" /><category term="Spring" /><category term="SpringBoot" /><category term="Maven" /><category term="Gradle" /><category term="JSP" /><category term="Thymeleaf Migration" /><category term="Review" /><summary type="html"><![CDATA[포트폴리오를 작성하다보니 생각보다 예전에 했던 프로젝트들이 회고해볼 만한 게 많아서 한 번 되짚어보려고 한다.]]></summary></entry><entry><title type="html">Integer Class</title><link href="http://localhost:4000/wiki/2024/04/30/integer-class.html" rel="alternate" type="text/html" title="Integer Class" /><published>2024-04-30T00:00:00+09:00</published><updated>2024-04-30T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/30/integer-class</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/30/integer-class.html"><![CDATA[<h4 id="string-tostringint-n-int-radix">String toString(int n, int radix)</h4>
<ul>
  <li>10진수를 N진수 형태의 문자열로 변환할 수 있다.
<br />
<br /></li>
</ul>

<h4 id="string-tobinarystringint-n">String toBinaryString(int n)</h4>
<ul>
  <li>10진수를 2진수 형태의 문자열로 변환할 수 있다.
<br />
<br /></li>
</ul>

<h4 id="string-tooctalstringint-n">String toOctalString(int n)</h4>
<ul>
  <li>10진수를 8진수 형태의 문자열로 변환할 수 있는 있다.
<br />
<br /></li>
</ul>

<h4 id="string-tohexastringint-n">String toHexaString(int n)</h4>
<ul>
  <li>10진수를 16진수 형태의 문자열로 변환할 수 있다.
<br />
<br /></li>
</ul>

<h4 id="int-parseintstring-s">int parseInt(String s)</h4>
<ul>
  <li>문자열을 10진수 int 타입으로 변환할 수 있다. (기본값: 10진수)
<br />
<br /></li>
</ul>

<h4 id="int-parseintstring-s-int-radix">int parseInt(String s, int radix)</h4>
<ul>
  <li>문자열을 지정한 진수(radix)로 읽어 int 타입으로 변환할 수 있다.
<br />
<br /></li>
</ul>

<h4 id="int-bitcountint-i">int bitCount(int i)</h4>
<ul>
  <li>정수를 2진수에서 1의 개수를 카운트해서 리턴한다.
    <ul>
      <li><em><code class="language-plaintext highlighter-rouge">1001110(2) → 4</code></em></li>
    </ul>
  </li>
  <li>관련 문제
    <ul>
      <li><a href="https://school.programmers.co.kr/learn/courses/30/lessons/12911">프로그래머스 다음 큰 숫자</a></li>
      <li><a href="https://leetcode.com/problems/binary-watch">leetcode binary watch</a>
<br />
<br /></li>
    </ul>
  </li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Java" /><category term="Integer" /><category term="Method" /><summary type="html"><![CDATA[String toString(int n, int radix) 10진수를 N진수 형태의 문자열로 변환할 수 있다.]]></summary></entry><entry><title type="html">아메리카노트 서버 구성 &amp;lt;5&amp;gt; 도메인 연결</title><link href="http://localhost:4000/wiki/2024/04/29/americanote-server5-connect-domain-name.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;5&amp;gt; 도메인 연결" /><published>2024-04-29T00:00:00+09:00</published><updated>2024-04-29T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/29/americanote-server5-connect-domain-name</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/29/americanote-server5-connect-domain-name.html"><![CDATA[<ul>
  <li>자동 배포까지 했으니 어느정도는 백엔드 코드를 서버에 올리는 것까지 했다고 할 수 있겠습니다.</li>
  <li>저도 여기가 마지막인 줄 알았으나..
<img src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/9ba32892-8688-4f23-aa75-806a8df95b37" alt="domain1" /></li>
  <li>첨부한 이미지는 프론트분이 API가 요청되지 않는다고 캡쳐해주신 에러 메세지입니다. 읽어보면 HTTPS인 프론트 도메인에서 HTTP인 백엔드 도메인으로 요청하는 부분에서 XMLHttpRequest 에러가 발생했습니다. 바로 CORS 문제입니다 ㅎㅎ</li>
  <li>검색해보니 프론트 쪽에서 간단하게 <code class="language-plaintext highlighter-rouge">&lt;meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"&gt;</code> 같은 HTML 코드를 넣어서 해결하는 방법도 있었지만, 그래도 저희는 해결되지 않아서 결국 도메인을 구매하기로 결정했습니다. (심지어 마감 전날 토요일에 ㅎㅎ)
<br />
<br /></li>
</ul>

<h4 id="1-카페24에서-도메인-구매">1. 카페24에서 도메인 구매</h4>
<ul>
  <li>아주 익숙한 카페24에서 도메인을 구매하기로 결정했습니다.</li>
  <li>좋은 이름이면 참 좋겠지만 프론트에서 API로 요청할 때만 필요하기 때문에 1년에 단돈 500원에 구매할 수 있는 <code class="language-plaintext highlighter-rouge">.store</code>를 선택했습니다.</li>
</ul>

<p><img width="875" alt="domain2" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/b015dcca-441f-4fe1-9067-0577379b6bc6" />
<br />
<br /></p>

<h3 id="2-서버에-nginx-설치하기">2. 서버에 Nginx 설치하기</h3>
<ul>
  <li>이제 도메인과 서버를 연결해주기 위해서 서버에 nginx를 설치해보겠습니다.</li>
  <li>먼저 설치하기 전에 패키지 목록을 업데이트 해줍니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt upgrade
</code></pre></div>    </div>
  </li>
  <li>그리고 nginx를 설치하겠습니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>nginx
</code></pre></div>    </div>
  </li>
  <li>계속할지 묻는 메시지가 표시되면 ‘Y’를 누르고 enter 키를 치다보면 설치가 완료됩니다.
  <img width="970" alt="domain3" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/4943ca29-1701-4786-9015-11ec1efd5ed1" />
    <ul>
      <li>저는 이렇게 하다가 중간에 에러가 발생했는데요, 이유는 IPV6 설정때문이었습니다. 해결해주기 위해 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/default</code> 파일에 접근해서 아래처럼 수정해줍니다.
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  server <span class="o">{</span>
      listen 80 default_server<span class="p">;</span>
      <span class="c"># listen [::]:80 default_server; # 이 부분 주석 처리</span>
    
      ...
    
      root /var/www/html<span class="p">;</span>
    
      <span class="c"># Add index.php to the list if you are using PHP</span>
      index index.html index.htm index.nginx-debian.html<span class="p">;</span>
    
      server_name _<span class="p">;</span>
    
      location / <span class="o">{</span>
              <span class="c"># First attempt to serve request as file, then</span>
              <span class="c"># as directory, then fall back to displaying a 404.</span>
              try_files <span class="nv">$uri</span> <span class="nv">$uri</span>/ <span class="o">=</span>404<span class="p">;</span>
      <span class="o">}</span>
  				...
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>이제 설치를 마쳤으면 nginx를 시작합니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>service nginx start
<span class="nb">sudo </span>service nginx status <span class="c"># nginx 상태 확인</span>
</code></pre></div>    </div>
    <p><img width="1045" alt="domain4" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/5447c65d-2df6-4850-945c-e19f8dd219b6" />
<br />
<br /></p>
  </li>
</ul>

<h4 id="3-방화벽-설정">3. 방화벽 설정</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>ufw app list
</code></pre></div></div>
<ul>
  <li>위의 명령어를 입력하여 방화벽 설정을 확인하면 방화벽 설정이 가능한 애플리케이션 목록이 나옵니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Available applications:
Nginx Full <span class="c"># 80, 443 포트 허용</span>
Nginx HTTP <span class="c"># 80 포트만 허용</span>
Nginx HTTPS <span class="c"># 443 포트만 허용</span>
OpenSSH
</code></pre></div>    </div>
  </li>
  <li>저희는 이 다음에 HTTPS까지 적용하기 위해서 ‘Nginx Full’ 방화벽을 허용해줍니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>ufw allow <span class="s1">'Nginx Full'</span>
<span class="nb">sudo </span>ufw status <span class="c"># 상태 체크</span>
</code></pre></div>    </div>
    <p>```bash
Status: inactive</p>
  </li>
</ul>

<p>To                         Action      From
–                         ——      —-
Nginx HTTP                 ALLOW       Anywhere
Nginx HTTP (v6)            ALLOW       Anywhere (v6)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 그리고 위처럼 상태가 inactive로 되어있으면 아래 명령어를 입력하여 활성화 시켜줍니다.
    - ***tip***: 아래 명령어를 입력하면 ssh 연결을 방해할 수도 있다는 경고 문구가 나오는데, 이때 y를 하기 전에 반드시 22번 포트를 허용하거나 제한해줍니다.
    &lt;img width="608" alt="domain5" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/429317de-249e-49fb-b516-7ebe01647d45"&gt;
    ```bash
    sudo ufw limit/allow 22
    ```
    - 처음 설정할 때는 이 부분을 몰라서 ssh에 들어갈 수 없게 되는 사태가 벌어졌지만, NCP 서버 콘솔에 원격으로 접속하는 곳으로 들어가 22번 포트를 허용하는 방식으로 겨우 해결했습니다…💦💦💦
```bash
sudo ufw enable
</code></pre></div></div>
<ul>
  <li>이제 public ip로 접근해보면 nginx 화면이 성공적으로 뜨는 것을 확인할 수 있습니다.</li>
</ul>

<p><img width="745" alt="domain6" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/d9ee761f-1926-4fce-82dd-85382f1eb292" />
<br />
<br /></p>

<h4 id="4-도메인-연결">4. 도메인 연결</h4>
<ul>
  <li>public ip로 뜨는 걸 봤으니 이제 도메인과 연결해주겠습니다.</li>
  <li>먼저 기본 nginx의 화면이 아닌 다른 화면으로 출력하기 위해 index.html 파일을 만들어줍니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /var/www/도메인이름/html <span class="c"># 폴더 생성</span>
<span class="nb">sudo chown</span> <span class="nt">-R</span> <span class="nv">$USER</span>:<span class="nv">$USER</span> /var/www/도메인이름/html <span class="c"># 소유자 설정</span>
<span class="nb">sudo chmod</span> <span class="nt">-R</span> 755 /var/www/도메인이름 <span class="c">#권한 설정</span>
<span class="nb">sudo </span>vi /var/www/도메인이름/html/index.html <span class="c"># index.html 파일 생성</span>
</code></pre></div>    </div>
  </li>
  <li>위에서 수정했던 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/default</code> 파일 대신 이번에는 도메인 이름으로 된 파일을 만들어서 아래처럼 설정해줍니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vi /etc/nginx/sites-available/도메인이름
<span class="c"># 위 파일로 자동으로 이동한 뒤 아래 내용 입력</span>
server <span class="o">{</span>
  listen 80<span class="p">;</span>

  root /var/www/도메인 이름/html<span class="p">;</span> <span class="c"># 위에서 만든 html 폴더</span>
  index index.html index.htm index.nginx-debian.html<span class="p">;</span>

  server_name 도메인 이름 www.도메인 이름<span class="p">;</span>

  location / <span class="o">{</span>
      try_files <span class="nv">$uri</span> <span class="nv">$uri</span>/ <span class="o">=</span>404<span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>위 파일을 nginx에서 연결해주기 위해 해당 파일을 sites-enabled 폴더에 심볼릭 링크 설정을 해줍니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/도메인이름 /etc/nginx/sites-enabled/
</code></pre></div>    </div>
  </li>
  <li>이제 브라우저에서 도메인을 입력하면 위에서 생성한 index.html이 확인할 수 있습니다.
<br />
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li>https://jaehyeon48.github.io/nginx/configure-nginx-on-ubuntu-2004/</li>
  <li><a href="https://velog.io/@xangj0ng/Linux-Ubuntu-Nginx-%EC%84%A4%EC%B9%98">https://velog.io/@xangj0ng/Linux-Ubuntu-Nginx-설치</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Server" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="DNS" /><summary type="html"><![CDATA[자동 배포까지 했으니 어느정도는 백엔드 코드를 서버에 올리는 것까지 했다고 할 수 있겠습니다. 저도 여기가 마지막인 줄 알았으나.. 첨부한 이미지는 프론트분이 API가 요청되지 않는다고 캡쳐해주신 에러 메세지입니다. 읽어보면 HTTPS인 프론트 도메인에서 HTTP인 백엔드 도메인으로 요청하는 부분에서 XMLHttpRequest 에러가 발생했습니다. 바로 CORS 문제입니다 ㅎㅎ 검색해보니 프론트 쪽에서 간단하게 &lt;meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"&gt; 같은 HTML 코드를 넣어서 해결하는 방법도 있었지만, 그래도 저희는 해결되지 않아서 결국 도메인을 구매하기로 결정했습니다. (심지어 마감 전날 토요일에 ㅎㅎ)]]></summary></entry><entry><title type="html">아메리카노트 서버 구성 &amp;lt;4&amp;gt; 자동 배포</title><link href="http://localhost:4000/wiki/2024/04/29/americanote-server4-automatical-deploy.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;4&amp;gt; 자동 배포" /><published>2024-04-29T00:00:00+09:00</published><updated>2024-04-29T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/29/americanote-server4-automatical-deploy</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/29/americanote-server4-automatical-deploy.html"><![CDATA[<hr />
<p>layout: post
title: 아메리카노트 서버 구성 &lt;4&gt; 자동 배포
subtitle: 
categories: wiki
tags: [Server, NaverCloudPlatform, Project, Deploy, GithubActions]
—</p>
<ul>
  <li>프로젝트를 서버에 배포해봤다면 번거롭다는 생각을 한번쯤 해봤을 것 같습니다. 그래서 이번에는 그 배포를 자동으로 진행해보겠습니다.</li>
  <li>자동 배포는 Github Actions의 self-hosted runner를 사용했습니다.
<br />
<br /></li>
</ul>

<h4 id="1-프로젝트-리포지토리에서-github-actions-runner-생성하기">1. 프로젝트 리포지토리에서 Github Actions Runner 생성하기</h4>
<ul>
  <li>프로젝트 리포지토리로 이동하여 Settings - Actions - Runners - New self-hosted runner 화면으로 이동합니다.
<img width="1344" alt="github-actions1" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/c576842e-5e21-4301-a477-b84727d1d967" />
<br />
<br /></li>
</ul>

<h4 id="2-서버에서-명령어-입력하기">2. 서버에서 명령어 입력하기</h4>
<ul>
  <li>서버에 Github Actions runner를 생성해주는 명령어들로 하나씩 차근차근 입력해 줍니다.</li>
  <li>마지막 명령어 실행 중 <strong>Must not run with sudo</strong> 라는 에러 메시지가 발생하면 <code class="language-plaintext highlighter-rouge">export RUNNER_ALLOW_RUNASROOT="1”</code>를 입력한 뒤 재시도하면 됩니다.
<img width="788" alt="github-actions2" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/43dad816-a9ed-4eaa-b137-d76272e537b6" /></li>
  <li>설치 완료 이후 화면
<img width="671" alt="github-actions3" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/9bf0bd39-e89e-468b-9755-6debf9c54ac6" /></li>
  <li>이후 아래 명령어를 입력하면 Github Actions를 수신할 준비가 완료됩니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> ./svc.sh <span class="nb">install
sudo</span> ./svc.sh start
</code></pre></div>    </div>
    <p><br />
<br /></p>
  </li>
</ul>

<h4 id="3-리포지토리에서-actons-workflow-생성">3. 리포지토리에서 Actons workflow 생성</h4>
<ul>
  <li>다시 리포지토리로 돌아가서 Actions 탭에서 왼쪽 상단의 New workflow를 클릭한 뒤 저희 프로젝트에 맞는 ‘Java with Gradle’을 선택하여 워크플로우를 생성합니다.</li>
  <li>이 워크플로우가 바로 Github Actions가 서버에서 수행할 업무들입니다.</li>
  <li>이전 페이지(<a href="https://dajeongdev.github.io/wiki/2024/04/29/deploy-project.html">&lt;3&gt; 프로젝트 배포</a>)에서 직접 설치 및 작성한 것과 동일하게 진행합니다.
    <ul>
      <li>JDK 17 설치</li>
      <li>YML 파일 생성</li>
      <li>Gradle 빌드</li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name: Auto Deploy

on:
  push:
    branches:
      - develop

<span class="nb">jobs</span>:
  build:

    runs-on: self-hosted

    steps:
      <span class="c"># checkout</span>
      - name: Checkout
        uses: actions/checkout@v4

      <span class="c"># JDK setting</span>
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: <span class="s1">'17'</span>
          distribution: <span class="s1">'zulu'</span>

      <span class="c"># secret yml file 생성</span>
      - name: Set secret yml
        run: |
          <span class="nb">mkdir</span> <span class="nt">-p</span> src/main/resources
          <span class="nb">echo</span> <span class="s2">"$"</span> | <span class="nb">base64</span> <span class="nt">--decode</span> <span class="o">&gt;</span> src/main/resources/application-database.yml
          <span class="nb">echo</span> <span class="s2">"$"</span> | <span class="nb">base64</span> <span class="nt">--decode</span> <span class="o">&gt;</span> src/main/resources/application-naver-token.yml
          <span class="nb">echo</span> <span class="s2">"$"</span> | <span class="nb">base64</span> <span class="nt">--decode</span> <span class="o">&gt;</span> src/main/resources/application-security.yml
          find src
        shell: bash

      <span class="c"># Gradle 권한 부여</span>
      - name: Grant permission <span class="k">for </span>gradlew
        run: <span class="nb">chmod</span> +x ./gradlew

      <span class="c"># 테스트 없이 빌드</span>
      - name: Build with Gradle
        run: ./gradlew clean build <span class="nt">-x</span> <span class="nb">test</span>

      <span class="c"># 포트가 사용 중이라면 종료</span>
      - name: Kill 8009 port <span class="k">if </span>exist
        run: |
            <span class="k">if </span><span class="nb">sudo </span>lsof <span class="nt">-i</span> :8009<span class="p">;</span> <span class="k">then
              </span><span class="nb">echo</span> <span class="s2">"Port 8009 is already in use. Killing the process..."</span>
              <span class="nb">sudo kill</span> <span class="nt">-9</span> <span class="sb">`</span><span class="nb">sudo </span>lsof <span class="nt">-t</span> <span class="nt">-i</span>:8009<span class="sb">`</span>
            <span class="k">fi</span>

      <span class="c"># build/libs 폴더 속 jar 파일 실행</span>
      - name: Execute Jar File
        run: |
          <span class="nb">sudo nohup </span>java <span class="nt">-jar</span> build/libs/americano-0.0.1-SNAPSHOT.jar 1&gt;/root/nohup/output.log 2&gt;/root/nohup/error.log &amp;
          <span class="nb">sleep </span>10
</code></pre></div></div>
<ul>
  <li>secret yml 파일의 경우 별도로 필요한 yml들을 Base64로 인코딩하여 리포지토리 Settings → Secrets and variables → Actions에서 Repository Secrets로 설정해주었습니다.
<img width="1340" alt="github-actions4" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/f2771b69-b97f-4255-9e94-6e3c1307921d" /></li>
  <li>또한, Github Actions self-hosted runner에서는 nohup이 적용되지 않아 자꾸 <code class="language-plaintext highlighter-rouge">Unable access to jarfile</code>가 발생하여, 결국 이 부분을 제거했더니 성공적으로 실행되었습니다.
    <ul>
      <li><del>nohup이 적용되지 않는 부분은 추후 원인을 찾아내면 꼭 작성해두도록 하겠습니다!</del> <strong>방법을 찾아서 추가하겠습니다. 또한 어이없게도 제가 nohup 이후에 설정한 게 없기 때문에 로그를 확인할 수 없어 필요하기도 했습니다..🥲</strong>
        <ul>
          <li>nohup의 출력은 프로젝트 내에서 권한 밖이기 때문에 발생한 에러라고 확인이 됩니다. 그래서 프로젝트 밖의 경로로 설정하여 표준 출력과 에러를 구분하여 로그를 전달하는 방식으로 스크립트를 추가했습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 이전
<span class="nb">sudo nohup </span>java <span class="nt">-jar</span> build/libs/americano-0.0.1-SNAPSHOT.jar &amp;
// 현재
 <span class="nb">sudo nohup </span>java <span class="nt">-jar</span> build/libs/americano-0.0.1-SNAPSHOT.jar 1&gt;/root/nohup/output.log 2&gt;/root/nohup/error.log &amp;
</code></pre></div></div>
<p><br />
<br /></p>

<h4 id="참고">참고</h4>
<ul>
  <li>https://e-room.tistory.com/145</li>
  <li>https://be-student.tistory.com/75</li>
  <li><a href="https://velog.io/@bjk1649/github-Action-%EB%A7%8C%EC%9C%BC%EB%A1%9C-%EC%A7%80%EC%86%8D%EC%A0%81-%EB%B0%B0%ED%8F%ACCD-%EB%AA%BB%ED%95%98%EB%82%98">https://velog.io/@bjk1649/github-Action-만으로-지속적-배포CD-못하나</a></li>
  <li>https://green-joo.tistory.com/26</li>
  <li><a href="https://velog.io/@chlee4858/20211205-github%EC%97%90%EC%84%9C-CICD-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0-github-action">https://velog.io/@chlee4858/20211205-github에서-CICD-적용하기-github-action</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Server" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="Deploy" /><summary type="html"><![CDATA[layout: post title: 아메리카노트 서버 구성 &lt;4&gt; 자동 배포 subtitle: categories: wiki tags: [Server, NaverCloudPlatform, Project, Deploy, GithubActions] — 프로젝트를 서버에 배포해봤다면 번거롭다는 생각을 한번쯤 해봤을 것 같습니다. 그래서 이번에는 그 배포를 자동으로 진행해보겠습니다. 자동 배포는 Github Actions의 self-hosted runner를 사용했습니다.]]></summary></entry><entry><title type="html">아메리카노트 서버 구성 &amp;lt;3&amp;gt; 프로젝트 배포</title><link href="http://localhost:4000/wiki/2024/04/29/americanote-server3-deploy-project.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;3&amp;gt; 프로젝트 배포" /><published>2024-04-29T00:00:00+09:00</published><updated>2024-04-29T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/29/americanote-server3-deploy-project</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/29/americanote-server3-deploy-project.html"><![CDATA[<p>서버와 데이터베이스를 생성했다면 이번에는 서버에 프로젝트를 배포해보겠습니다.
<br />
<br /></p>

<h4 id="1-서버에-접근하기">1. 서버에 접근하기</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh username@public-ip <span class="nt">-p</span> 22<span class="o">(</span>허용 포트<span class="o">)</span>
<span class="c"># password</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="2-서버에-java-설치">2. 서버에 JAVA 설치</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>openjdk-17-jdk
java <span class="nt">--version</span> <span class="c"># 자바 버전 확인</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="3-프로젝트-가져오기">3. 프로젝트 가져오기</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone <span class="nt">--branch</span> 가져올브랜치 https://github.com/깃헙아이디/레포지토리명.git <span class="c"># 프로젝트 복제</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="4-별도로-필요한-yml-파일이-있다면-optional">4. 별도로 필요한 yml 파일이 있다면 (optional)</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>Americanote <span class="c"># 리포지토리로 들어가기</span>
<span class="nb">cd </span>src/main/resources <span class="c"># yml 파일이 위치할 resources 폴더로 이동</span>
<span class="nb">cat</span> <span class="o">&gt;</span> ~.yml <span class="c"># yml 파일 생성 및 편집</span>
<span class="c"># yml 파일 내용 붙여넣기</span>
<span class="c"># 필요한 yml 파일을 모두 만들었으면 다시 리포지토리 홈으로 돌아갑니다.</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="5-gradle-빌드-후-실행하기">5. Gradle 빌드 후 실행하기</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./gradlew clean build <span class="nt">-x</span> <span class="nb">test</span> <span class="c"># 테스트 없이 처음부터 빌드</span>
<span class="nb">cd </span>build/libs <span class="c"># jar 파일이 존재하는 폴더로 이동</span>
ll 혹은 <span class="nb">ls</span> <span class="c"># 폴더 보기</span>
<span class="nb">nohup </span>java <span class="nt">-jar</span> <span class="o">[</span>이름-SNAPSHOT.jar] &amp;
</code></pre></div></div>
<ul>
  <li>nohup
    <ul>
      <li>no hang up의 약자, 말그대로 끊지마!</li>
      <li>사용자가 세션과 연결을 종료해도, 데몬 형태로 실행하게 하여 해당 프로세스가 종료되지 않습니다.</li>
    </ul>
  </li>
  <li>&amp;
    <ul>
      <li>프로그램 실행 시 마지막에 붙여주면 백그라운드에서 해당 프로세스가 실행됩니다.
<br />
  → 어떤 프로그램을 종료없이 백그라운드에서 실행시킬 때 <code class="language-plaintext highlighter-rouge">nohup ~ &amp;</code> 조합을 사용하는 게 가장 확실하고 안전합니다.
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="6-로그-확인">6. 로그 확인</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 실행 후 ll 이나 ls로 확인해보면 nohup.out이 생성됩니다.</span>
<span class="nb">tail</span> <span class="nt">-f</span> nohup.out <span class="c"># 실시간 업데이트 로그</span>
<span class="nb">cat </span>nohup.out     <span class="c"># 현재까지 로그</span>
</code></pre></div></div>
<ul>
  <li>제대로 실행되었는지 확인하기 위해 로그를 실행 후 로그를 반드시 확인하는 편입니다.
<br />
<br /></li>
</ul>

<h4 id="7-만약-이미-프로젝트가-실행-중이라면-종료하고-실행하자">7. 만약 이미 프로젝트가 실행 중이라면? 종료하고 실행하자</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netstat <span class="nt">-tulpn</span> <span class="c"># 실행 중인 프로세스 확인</span>
<span class="nb">kill</span> <span class="nt">-9</span> <span class="o">[</span>PID 번호]
</code></pre></div></div>
<ul>
  <li>Gradle 빌드 후 실행하기 전에 한번쯤 확인하면 좋겠습니다.
<br />
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li><a href="https://1.theapplemango.com/entry/%EB%84%A4%EC%9D%B4%EB%B2%84-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%ED%94%8C%EB%9E%AB%ED%8F%BCNCP-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%B6%95-%EB%B0%8F-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B0%B0%ED%8F%AC%EA%B9%8C%EC%A7%80-2">https://1.theapplemango.com/entry/네이버-클라우드-플랫폼NCP-서버-구축-및-스프링-배포까지-2</a></li>
  <li><a href="https://joonyon.tistory.com/entry/%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%9C-nohup-%EA%B3%BC-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%82%AC%EC%9A%A9%EB%B2%95">https://joonyon.tistory.com/entry/쉽게-설명한-nohup-과-백그라운드-명령어-사용법</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Server" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="Deploy" /><summary type="html"><![CDATA[서버와 데이터베이스를 생성했다면 이번에는 서버에 프로젝트를 배포해보겠습니다.]]></summary></entry><entry><title type="html">아메리카노트 서버 구성 &amp;lt;2&amp;gt; MySQL 데이터베이스 생성</title><link href="http://localhost:4000/wiki/2024/04/29/americanote-server2-create-mysql-database.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;2&amp;gt; MySQL 데이터베이스 생성" /><published>2024-04-29T00:00:00+09:00</published><updated>2024-04-29T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/29/americanote-server2-create-mysql-database</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/29/americanote-server2-create-mysql-database.html"><![CDATA[<p>이번에는 NCP에서 MySQL DB Server를 생성하고 연결해보겠습니다.
<br />
<br /></p>

<h4 id="db-server-생성">DB Server 생성</h4>
<p><img width="678" alt="create-mysql1" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/44d6bbc1-bc7a-46b8-ba8f-11681852aac9" /></p>
<ul>
  <li>고가용성까지는 필요 없기 때문에 해제를 해주고, 이전 단계에서 만들었던 VPC와 Subnet을 선택해주었습니다.
<br />
<br />
<br /></li>
</ul>

<p><img width="551" alt="create-mysql2" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/a51e2e02-7af7-4614-a433-f81839ad3545" /></p>
<ul>
  <li>기본 설정에서 거의 건드리지 않고 DB server와 서비스 이름만 지정해주었습니다.
<br />
<br />
<br /></li>
</ul>

<p><img width="682" alt="create-mysql3" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/c4d4c493-9ce9-45e5-94b3-54ee3004eec0" /></p>
<ul>
  <li>USER_ID와 USER 암호로 MySQL admin을 생성해줍니다.</li>
  <li>HOST는 접속할 Client IP를 입력하는 건데 아래 예시처럼 전체 접속을 허용해주기 위해 %를 입력했습니다.
<br />
<br />
<br /></li>
</ul>

<p><img width="362" alt="create-mysql4" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/95182b3c-e4e8-4d00-8ed5-7061fd7667dd" /></p>
<ul>
  <li>또한 백업 설정은 추가 요금이 발생한다길래 과감히 포기했습니다^^..</li>
  <li>다음을 누르고 최종 확인을 하면 몇 분 안에 DB 서버가 생성됩니다.
<br />
<br />
<br /></li>
</ul>

<h4 id="방화벽acg-설정">방화벽(ACG) 설정</h4>
<ul>
  <li>생성 후 끝이 아니라 DB에 접속하기 위해 방화벽을 설정해줍니다.</li>
  <li>참고로 DB에 0.0.0.0으로 모두 허용해주는 게 위험하다고 생각해서 자주 쓰는 IP들만 등록해두었습니다.</li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="MySQL" /><category term="DataBase" /><summary type="html"><![CDATA[이번에는 NCP에서 MySQL DB Server를 생성하고 연결해보겠습니다.]]></summary></entry><entry><title type="html">아메리카노트 서버 구성 &amp;lt;6&amp;gt; HTTPS 적용</title><link href="http://localhost:4000/wiki/2024/04/29/americanote-server6-apply-https-to-the-domain.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;6&amp;gt; HTTPS 적용" /><published>2024-04-29T00:00:00+09:00</published><updated>2024-04-29T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/29/americanote-server6-apply-https-to-the-domain</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/29/americanote-server6-apply-https-to-the-domain.html"><![CDATA[<ul>
  <li>이전 단계에서 진행했던 방화벽에서의 80, 443 포트 허용과 도메인이 있다면 이제 기간은 짧지만 무료로 받을 수 있는 Letsencrypt의 SSL 인증서를 발급 받아보겠습니다.
<br />
<br /></li>
</ul>

<h4 id="ssl-인증서-발급받기">SSL 인증서 발급받기</h4>
<ul>
  <li>인증서를 발급받기 위해 letsencrypt의 certbot을 설치해주고, 인증서를 발급받습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update <span class="c"># 패키지 업데이트</span>
<span class="nb">sudo </span>apt <span class="nb">install </span>certbot python3-certbot-nginx
<span class="nb">sudo </span>certbot <span class="nt">--nginx</span> <span class="nt">-d</span> 도메인이름 <span class="nt">-d</span> www.도메인이름
</code></pre></div></div>

<ul>
  <li>첫 실행 시에는 이메일을 입력하고 약관에 동의해야 합니다.</li>
  <li>이후 certbot이 letsencrypt 서버와 통신 중 도메인이 유효한치 확인하는 과정을 거칩니다.
    <ul>
      <li>저는 이 부분에서 에러가 참 많이 발생했는데요 ㅎㅎ 하나씩 살펴보겠습니다.
        <ol>
          <li><strong>/well-known/acme-challenge/ 폴더가 허용되지 않았습니다.</strong>
            <ul>
              <li>
                <p>이 부분은 Nginx에서 적용하는 부분이라 이전 단계에서 만들었던 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/도메인이름</code> 파일에서 추가해주었습니다.</p>

                <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  server <span class="o">{</span>
          listen 80 default_server<span class="p">;</span>
          listen <span class="o">[</span>::]:80 default_server<span class="p">;</span>
                
          server_name 도메인이름 www.도메인이름<span class="p">;</span>
                
          location ~ /<span class="se">\.</span>well-known/acme-challenge/ <span class="o">{</span>
          allow all<span class="p">;</span>
          root /var/www/letsencrypt<span class="p">;</span>
          <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>                </div>
              </li>
            </ul>
          </li>
          <li><strong>도메인에 A 레코드를 적용되어 있지 않았습니다.</strong>
            <ul>
              <li>A 레코드 적용을 위해 NCP에서 Global Domain에 도메인을 추가하고, A 레코드를 추가해주었습니다.
  <img width="679" alt="https1" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/3abce503-be85-43fe-8531-612c95578743" /></li>
              <li>하지만 이 Global Domain의 네임서버를 카페24의 도메인에 설정해주는 과정에서 24시간이 걸린다는 소식에 아주 멘탈이 탈탈 털릴 뻔 했지만… 다행히 12시간 정도 뒤에 사용이 가능했습니다😂
  <img width="544" alt="https2" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/8f6df708-93fa-4e43-8709-e2ad85b0c689" /></li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p><img width="770" alt="https3" src="https://github.com/dajeongdev/dajeongdev.github.io/assets/61612976/f52a2ee6-ea91-475c-ba0e-8252c28a2993" /></p>
<ul>
  <li>그리하여 드디어 간절히 기다리던 발급 성공 화면을 보게 되면 SSL 발급에 성공한 겁니다.</li>
  <li>이제 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/도메인이름</code> 파일에 접근해보면 자동으로 SSL이 적용된 것을 확인할 수 있습니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server <span class="o">{</span>
        listen  443 ssl<span class="p">;</span>
        server_name americanote.store www.americanote.store<span class="p">;</span>

        <span class="c">#access_log /var/log/nginx/proxy/access.log;</span>
        <span class="c">#error_log /var/log/nginx/proxy/error.log;</span>

        ssl_certificate /etc/letsencrypt/live/americanote.store/fullchain.pem<span class="p">;</span>
        ssl_certificate_key /etc/letsencrypt/live/americanote.store/privkey.pem<span class="p">;</span>

        location / <span class="o">{</span> <span class="c"># 추가</span>
                proxy_pass http://127.0.0.1:8009<span class="p">;</span>

        <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>참고로 <code class="language-plaintext highlighter-rouge">location / { … }</code> 부분까지 설정해주어야 현재 서버의 8009로 실행되고 있는 프로세스로 프록시가 요청을 전달해줍니다.
<br />
<br /></li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li><a href="https://velog.io/@curiosity806/nginx-Lets-Encrypt-SSL-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89">https://velog.io/@curiosity806/nginx-Lets-Encrypt-SSL-인증서-발급</a></li>
  <li><a href="https://jaehyeon48.github.io/nginx/configure-nginx-on-ubuntu-2004">Ubuntu 20.04에서 Nginx 설치 및 설정하기</a></li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="MySQL" /><category term="DataBase" /><summary type="html"><![CDATA[이전 단계에서 진행했던 방화벽에서의 80, 443 포트 허용과 도메인이 있다면 이제 기간은 짧지만 무료로 받을 수 있는 Letsencrypt의 SSL 인증서를 발급 받아보겠습니다.]]></summary></entry><entry><title type="html">아메리카노트 서버 구성 &amp;lt;1&amp;gt; Linux 서버 생성</title><link href="http://localhost:4000/wiki/2024/04/28/americanote-server1-create-linux-server.html" rel="alternate" type="text/html" title="아메리카노트 서버 구성 &amp;lt;1&amp;gt; Linux 서버 생성" /><published>2024-04-28T00:00:00+09:00</published><updated>2024-04-28T00:00:00+09:00</updated><id>http://localhost:4000/wiki/2024/04/28/americanote-server1-create-linux-server</id><content type="html" xml:base="http://localhost:4000/wiki/2024/04/28/americanote-server1-create-linux-server.html"><![CDATA[<h4 id="배경">배경</h4>
<ul>
  <li>비사이드 포텐데이403 프로젝트를 진행하면서 Linux 서버를 생성하기 위해 순서대로 정리해봤습니다.
<br />
<br /></li>
</ul>

<h4 id="1-os-선택">1. OS 선택</h4>
<ul>
  <li>레퍼런스가 많고 지속적으로 업데이트가 되고 있는 <strong>Ubuntu</strong>로 선택함
<br />
<br /></li>
</ul>

<h4 id="2-vpcvirtual-private-cloud-설정">2. VPC(Virtual Private Cloud) 설정</h4>
<ul>
  <li>전용 네트워크</li>
  <li>필수
    <ul>
      <li>이름, IP 주소 범위
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="3-subnet-설정">3. Subnet 설정</h4>
<ul>
  <li>VPC 내에 세분화된 격리 공간 제공</li>
  <li>필수
    <ul>
      <li>이름, VPC, IP 주소 범위(VPC 범위 내), 가용 Zone, Network ACL, Internet Gateway 전용 여부(public), 용도
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="4-서버-생성">4. 서버 생성</h4>
<ul>
  <li>서버 타입: Standard</li>
  <li>서버 스펙: s2-g3(vCPU 2EA, Memory 8GB)</li>
  <li>스토리지: CB1 (기본 스토리지, 10GB)</li>
  <li>서버 인증키(pem)
    <ul>
      <li>잘 보관해두기
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h4 id="5-acg방화벽-설정">5. ACG(방화벽) 설정</h4>
<ul>
  <li>22
    <ul>
      <li>접속할 PC</li>
      <li>IP 입력</li>
      <li><strong>팀원들 IP 입력 필요</strong> ⭐</li>
    </ul>
  </li>
  <li>80, 443
    <ul>
      <li>URL 링크로 접속</li>
      <li>클라이언트를 위한 포트</li>
      <li>80: HTTP</li>
      <li>443: HTTPS</li>
    </ul>
  </li>
  <li>81
    <ul>
      <li>Nginx Proxy Manager의 접속을 위한 포트</li>
    </ul>
  </li>
  <li>3306
    <ul>
      <li>DB 접속
<br />
<br /></li>
    </ul>
  </li>
</ul>

<p><strong>참고</strong></p>
<ul>
  <li>https://velog.io/@ejh990521/CentOS-vs-Ubuntu</li>
  <li>https://docs.3rdeyesys.com/compute/ncloud_compute_server_vpc_create.html</li>
</ul>]]></content><author><name>Dajeong Park</name></author><category term="wiki" /><category term="Server" /><category term="NaverCloudPlatform" /><category term="Project" /><category term="Linux" /><summary type="html"><![CDATA[배경 비사이드 포텐데이403 프로젝트를 진행하면서 Linux 서버를 생성하기 위해 순서대로 정리해봤습니다.]]></summary></entry></feed>